# The Rust Programming Language Notes

* Rust is a compiled statically-typed language
* [5 ways to instantiate Rust structs in tests](https://jmmv.dev/2023/10/rust-test-structs.html)
* [999 crates of Rust on the wall](https://lawngno.me/blog/2024/06/10/divine-provenance.html)
* [Aquascope Playground](https://cel.cs.brown.edu/aquascope/)
  * [Aquascope](https://github.com/cognitive-engineering-lab/aquascope)
* [Async fn in trait, for real this time](https://fasterthanli.me/series/updating-fasterthanli-me-for-2022/part-7)
* [Async Rust in Practice: Performance, Pitfalls, Profiling](https://www.scylladb.com/2022/01/12/async-rust-in-practice-performance-pitfalls-profiling/)
* [Async: What is blocking?](https://ryhl.io/blog/async-what-is-blocking/)
* [Asynchronous Destructors](https://boats.gitlab.io/blog/post/poll-drop/)
* [Being Rusty: Discovering Rust's design axioms](https://smallcultfollowing.com/babysteps/blog/2023/12/07/rust-design-axioms/)
* [Code Like a Pro in Rust book code](https://github.com/brndnmtthws/code-like-a-pro-in-rust-book)
* [Data Parallelism with Rust and Rayon](https://www.shuttle.rs/blog/2024/04/11/using-rayon-rust)
* [Developer-first diagnostics for Rust applications](https://kodraus.github.io/rust/2024/06/13/introducing-emit.html)
* [Don't Use Preludes And Globs](https://corrode.dev/blog/dont-use-preludes-and-globs/)
* [Dump C++ and in Rust you should trust, Five Eyes agencies urge](https://www.theregister.com/2023/12/07/memory_correction_five_eyes/)
* [Everything you need to know about testing in Rust](https://www.shuttle.rs/blog/2024/03/21/testing-in-rust)
* [Exercism](https://exercism.org/tracks/rust)
* [Fast Rust Builds](https://matklad.github.io/2021/09/04/fast-rust-builds.html)
* [`fp-core.rs`](https://github.com/JasonShin/fp-core.rs)
* [Home Page](https://www.rust-lang.org/)
  * [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/)
  * [Blog](https://blog.rust-lang.org/)
    * [Announcing Rust 1.80.0](https://blog.rust-lang.org/2024/07/25/Rust-1.80.0.html)
    * [Announcing Rust 1.80.1](https://blog.rust-lang.org/2024/08/08/Rust-1.80.1.html)
    * [Announcing Rust 1.81.0](https://blog.rust-lang.org/2024/09/05/Rust-1.81.0.html)
    * [Announcing Rust 1.82.0](https://blog.rust-lang.org/2024/10/17/Rust-1.82.0.html)
    * [Announcing Rust 1.83.0](https://blog.rust-lang.org/2024/11/28/Rust-1.83.0.html)
    * [Announcing Rust 1.84.0](https://blog.rust-lang.org/2025/01/09/Rust-1.84.0.html)
    * [Announcing Rust 1.85.0 and Rust 2024](https://blog.rust-lang.org/2025/02/20/Rust-1.85.0.html)
  * [Book](https://doc.rust-lang.org/book/)
  * [Command Line Applications in Rust](https://rust-cli.github.io/book/)
  * [Learn Rust](https://www.rust-lang.org/learn)
  * [Reference Guide](https://doc.rust-lang.org/reference/index.html)
  * [RFC Book](https://rust-lang.github.io/rfcs/)
  * [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
  * [Rust by Example](https://doc.rust-lang.org/rust-by-example/index.html)
  * [Rust Conversions](https://nicholasbishop.github.io/rust-conversions/)
  * [Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/)
  * [Rust Design Patterns](https://rust-unofficial.github.io/patterns/)
  * [Secure Rust Guidelines](https://anssi-fr.github.io/rust-guide/)
  * [The Little Book of Rust Macros](https://veykril.github.io/tlborm/) [[mirror](https://danielkeep.github.io/tlborm/book/)]
  * [The Rustonomicon](https://doc.rust-lang.org/nomicon/)
  * [The `rustdoc` book](https://doc.rust-lang.org/rustdoc/)
  * [The `rustup` book](https://rust-lang.github.io/rustup/)
* [How can I deserialize an optional field with custom functions using Serde?](https://stackoverflow.com/questions/44301748/how-can-i-deserialize-an-optional-field-with-custom-functions-using-serde)
* [How to Handle Errors in Rust: A Comprehensive Guide](https://dev.to/nathan20/how-to-handle-errors-in-rust-a-comprehensive-guide-1cco)
* [How to initialize the logger for integration tests?](https://stackoverflow.com/questions/30177845/how-to-initialize-the-logger-for-integration-tests)
* [Karol Kuczmarski's Blog](http://xion.io/)
  * [Better location for unit tests in Rust](http://xion.io/post/code/rust-unit-test-placement.html)
* [Large Rust Workspaces](https://matklad.github.io/2021/08/22/large-rust-workspaces.html)
* [Learning Material for Idiomatic Rust](https://corrode.dev/blog/idiomatic-rust-resources/)
* [Learning Rust](https://github.com/danbev/learning-rust)
* [Learning Rust With Entirely Too Many Linked Lists](https://rust-unofficial.github.io/too-many-lists/)
* [Long-Term Rust Project Maintenance](https://corrode.dev/blog/long-term-rust-maintenance/)
* [Memory safety for the Internet's most critical infrastructure](https://www.memorysafety.org/)
  * [Rustls Outperforms OpenSSL and BoringSSL](https://www.memorysafety.org/blog/rustls-performance-outperforms/)
  * [What is memory safety and why does it matter?](https://www.memorysafety.org/docs/memory-safety/)
* [Minimizing Rust Binary Size](https://github.com/johnthagen/min-sized-rust)
  * [151-byte static Linux binary in Rust](https://mainisusuallyafunction.blogspot.com/2015/01/151-byte-static-linux-binary-in-rust.html)
* [Pin and suffering](https://fasterthanli.me/articles/pin-and-suffering)
* [Pretty State Machine Patterns in Rust](https://hoverbear.org/blog/rust-state-machine-pattern/)
* [Procedural Macros Workshop](https://github.com/dtolnay/proc-macro-workshop)
* [Profiling async applications in Rust (video)](https://www.youtube.com/watch?v=8FAdY_0DpkM)
* [Review of RustRover: A New IDE for Rust developers by JetBrains](https://linuxel.com/review-of-rustrover-a-new-ide-for-rust-developers-by-jetbrains/)
* [Rust 1.80.0: Top 10 Most Interesting Things & Blog Highlights](https://www.youtube.com/watch?v=iwV-T5yHJQw)
* [Rust Compiler Explorer](https://rust.godbolt.org/)
* [Rust Data Modelling Without Classes (video)](https://www.youtube.com/watch?v=z-0-bbc80JM)
* [Rust Foundation](https://foundation.rust-lang.org/)
* [Rust Language Cheat Sheet](https://cheats.rs/)
* [Rust Maintenance Checklist](https://corrode.notion.site/Rust-Maintenance-Checklist-3fa116db4c6149cbacbe3c16f81c6bb0)
* [Rust Trends](https://rust-trends.com/)
  * [Emulators and memory management visualization](https://rust-trends.com/newsletter/emulators-and-memory-management-visualization/)
* [rust-learning](https://github.com/ctjhoa/rust-learning)
* [RustConf](https://rustconf.com/)
* [Shipyard.rs (Private Cargo Registry Service)](https://shipyard.rs/) [[book](https://docs.shipyard.rs/)]
* [Source Code](https://github.com/rust-lang/rust)
* [Swatinem Blog](https://swatinem.de/blog/)
  * [The magic of scope guards](https://swatinem.de/blog/magic-scope-guards/)
* [The Four Horsemen of Bad Rust Code](https://fosdem.org/2024/schedule/event/fosdem-2024-2434-the-four-horsemen-of-bad-rust-code/) [[slides](https://speakerdeck.com/mre/the-4-horsemen-of-bad-rust-code)] [[repo](https://github.com/corrode/four-horsemen-talk)]
* [The Rust communityâ€™s crate registry](https://crates.io/)
* [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
* [The Story of Tail Call Optimizations in Rust](https://dev.to/seanchen1991/the-story-of-tail-call-optimizations-in-rust-35hf)
* [The ultimate guide to Rust newtypes](https://www.howtocodeit.com/articles/ultimate-guide-rust-newtypes)
* [Tips For Faster Rust Compile Times](https://corrode.dev/blog/tips-for-faster-rust-compile-times/)
* [Translating All C to Rust (TRACTOR)](https://www.darpa.mil/program/translating-all-c-to-rust)
* [Understanding the `AtomicUsize` in `std::sync::atomic`](https://medium.com/@teamcode20233/understanding-the-atomicusize-in-std-sync-atomic-rust-tutorial-b3b43c77a2b)
* [What it takes to keep Tokio running (video)](https://www.youtube.com/watch?v=Lc3aw_NIOt0)

## Installation

Using a distribution independent method (recommended):
```sh
$ : "${RUST_PROFILE:=default}"  # Other possibilities: minimal, complete
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh -s -- -y --profile ${RUST_PROFILE}
```
* this installs Rust under user's home directory, isolated from distribution
  installation
  * `PATH` environment variable is updated to include `~/.cargo/bin`
  * needs a shell to be restarted or `source ~/.cargo/env` to be run
* some components are installed via `rustup`:
  ```sh
  rustup component add ...
  ```
* to use binaries installed using `rustup component add ...`, additional
  location need to be added to `PATH`:
  ```sh
  $ X=$(rustc --print target-libdir)
  $ PATH=${X%/*}/bin:${PATH} ...
  ```

### Removal

First:
```sh
$ rm -rf ~/.cargo ~/.rustup
```

Then remove any mention of `. "$HOME/.cargo/env"` from:
* `~/.bash_profile`
* `~/.profile`
* `~/.zshenv`

### GitHub Actions

* [`actions-rust-lang/setup-rust-toolchain`](https://github.com/actions-rust-lang/setup-rust-toolchain)
* [`dtolnay/rust-toolchain`](https://github.com/dtolnay/rust-toolchain)

## Tools

### Cargo

[Cargo](https://doc.rust-lang.org/cargo/index.html) ([source code](https://github.com/rust-lang/cargo))
is a package manager for Rust. A package in the Rust world is called *crate*.
Using `cargo` is a recommended way how to create and maintain Rust projects.

Tips, tricks, and hacks:
* [Cargo `--offline`](https://www.ncameron.org/blog/cargo-offline/)
* [How do I pin indirect dependencies of a crate?](https://stackoverflow.com/questions/27770031/how-do-i-pin-indirect-dependencies-of-a-crate)
* [Nine Rust Cargo.toml Wats and Wat Nots](https://towardsdatascience.com/nine-rust-cargo-toml-wats-and-wat-nots-1e5e02e41648)

* To create a new project in Rust, type:
  ```sh
  $ cargo new --name project_name project_slug
  ```
  This creates the `project_slug` directory with `Cargo.toml` project
  configuration file and `src/` directory containing project sources. The
  content of `Cargo.toml` has the following structure:
  ```toml
  [package]
  # The name of the package, e.g. "foo":
  name = "<name>"
  # The version of the package, e.g. "0.1.0":
  version = "<version>"
  # The Rust language edition used to compile this project, e.g. "2021":
  edition = "<edition>"

  [dependencies]
  # A dependency is of the format `<crate name> = "<version>"`, where <version>
  # follows the semantic versioning scheme. An example of a dependency is
  # `rand = "0.8.5"`, where "0.8.5" is a shorthand for "^0.8.5" which means any
  # version that is at least "0.8.5" but below "0.9.0". Cargo considers that
  # any of these versions are compatible with "0.8.5".
  ```
  When `--name` is omitted, the name of the project is derived from the name of
  the project directory (`project_slug`).
* To build the project, type:
  ```sh
  $ cargo build
  ```
  This will build your project and
  1. puts the resultant executable inside `./target/debug` directory;
  1. creates `Cargo.lock` keeping the track of exact versions of project
     dependencies. When you run `cargo build` first time, Cargo resolves the
     project dependencies and writes the exact versions of crates to
     `Cargo.lock`. Next time Cargo reuse the information from `Cargo.lock`
     instead of resolving dependencies again. If a dependency needs to be
     updated, run `cargo update`.
* To build a release of your project, type:
  ```sh
  $ cargo build --release
  ```
  This will build your project with enabled optimizations and put the resultant
  executable inside `./target/release` directory.
* To pre-build your project's dependencies as a container layer:
  * [`cargo-chef`](https://github.com/LukeMathWalker/cargo-chef) [[crate](https://crates.io/crates/cargo-chef)] [[howto](https://www.lpalmieri.com/posts/fast-rust-docker-builds/)]
* To build and run the project, type:
  ```sh
  $ cargo run
  ```
* To check whether the project compiles, type:
  ```sh
  $ cargo check
  ```
  This will produce no executable.
* To check the project with various options:
  * [`cargo hack`](https://github.com/taiki-e/cargo-hack) [[doc](https://docs.rs/crate/cargo-hack/latest)] [[crate](https://crates.io/crates/cargo-hack)]
* To build and test with all feature flag combinations:
  * [`cargo {build,check,test}-all-features`](https://github.com/frewsxcv/cargo-all-features) [[doc](https://docs.rs/cargo-all-features/latest/cargo_all_features/)] [[crate](https://crates.io/crates/cargo-all-features)]
* To run tests with injected bugs:
  * [`cargo mutants`](https://github.com/sourcefrog/cargo-mutants) [[book](https://mutants.rs/)] [[doc](https://docs.rs/crate/cargo-mutants/latest)] [[crate](https://crates.io/crates/cargo-mutants)]
* To update the project dependencies, type:
  ```sh
  $ cargo update
  ```
  This will look for new bug fixes of crates, download them and update
  `Cargo.lock`.
* To launch the documentation of your project dependencies, type:
  ```sh
  $ cargo doc --open
  ```
* To audit dependencies for crates with security vulnerabilities reported to
  the [RustSec Advisory Database](https://github.com/RustSec/advisory-db/):
  * [`cargo audit`](https://github.com/rustsec/rustsec) [[doc](https://docs.rs/cargo-audit/latest/cargo_audit/)] [[crate](https://crates.io/crates/cargo-audit)]
* To generate a dependency graph:
  * [`cargo depgraph`](https://sr.ht/~jplatte/cargo-depgraph/) [[crate](https://crates.io/crates/cargo-depgraph)]
* To generate a flame graph:
  * [`cargo flamegraph`](https://github.com/flamegraph-rs/flamegraph) [[crate](https://crates.io/crates/flamegraph)]
* To visualize/analyze crate's internal structure:
  * [`cargo modules`](https://github.com/regexident/cargo-modules) [[doc](https://docs.rs/cargo-modules/latest/cargo_modules/)] [[crate](https://crates.io/crates/cargo-modules/)]
* To find unused dependencies:
  * using [`cargo machete`](https://github.com/bnjbvr/cargo-machete)
  * using [`cargo +nightly udeps`](https://github.com/est31/cargo-udeps)
  * using `RUSTFLAGS=-Wunused-crate-dependencies`:
    ```sh
    $ export RUSTFLAGS=-Wunused-crate-dependencies
    $ cargo build
    $ cargo check --all --all-targets
    ```
  * see more [here](https://gist.github.com/helio-frota/f6a48303aefdc22578661babacb153dd)
* To DRY up `Cargo.toml` manifests:
  * [`cargo autoinherit`](https://github.com/mainmatter/cargo-autoinherit)
* To run your custom command/task, see:
  * [`cargo xtask`](https://github.com/matklad/cargo-xtask/)
  * [Custom tasks in Cargo](http://aturon.github.io/tech/2018/04/05/workflows/)
* To install a crate from its source, type:
  ```sh
  $ cargo install
  ```
  * to download and install binary build of crate use
    [`cargo-binstall`](https://github.com/cargo-bins/cargo-binstall) extension:
    ```sh
    $ cargo binstall
    ```
* To clean up unused build files:
  * [`cargo sweep`](https://github.com/holmgr/cargo-sweep) [[crate](https://crates.io/crates/cargo-sweep)]
* To prune crate dependencies in target folder:
  * [`cargo prune`](https://github.com/ustulation/cargo-prune) [[crate](https://crates.io/crates/cargo-prune)]
* To cleanup `${CARGO_HOME}` cache:
  * [`cargo trim`](https://github.com/iamsauravsharma/cargo-trim) [[crate](https://crates.io/crates/cargo-trim)]
* To watch over your project's source for changes:
  * [`cargo watch`](https://github.com/watchexec/cargo-watch) [[home](https://watchexec.github.io/)] [[doc](https://docs.rs/crate/cargo-watch/latest)] [[doc2](https://watchexec.github.io/docs/cargo-watch/)] [[crate](https://crates.io/crates/cargo-watch)]

#### Issues

* [`default-features = false` not working for dependency inside workspace.](https://github.com/rust-lang/cargo/issues/8366)
* [Disabled optional weak dependencies end up in `Cargo.lock`](https://github.com/rust-lang/cargo/issues/10801)
* [Environment variable for Cargo Workspace](https://github.com/rust-lang/cargo/issues/3946)
* [Have an option to make Cargo attempt to clean up after itself.](https://github.com/rust-lang/cargo/issues/6229)
* [Support for pre-built dependencies](https://github.com/rust-lang/cargo/issues/1139)
* [Tracking Issue for garbage collection](https://github.com/rust-lang/cargo/issues/12633)
  * [Add cache garbage collection](https://github.com/rust-lang/cargo/pull/12634)

### Clippy

[`clippy`](https://doc.rust-lang.org/clippy/)
([repo](https://github.com/rust-lang/rust-clippy)) is a tool for linting a
source code written in Rust.

Tips, tricks, and hacks:
* [Mastering Clippy: Elevating Your Rust Code Quality](https://rust-trends.com/posts/mastering-clippy-elevating-your-rust-code-quality/)
* pedantic `clippy` checks:
  ```sh
  cargo clippy -- \
    -W clippy::single_match \
    -W clippy::needless_match \
    -W clippy::needless_late_init \
    -W clippy::redundant_pattern_matching \
    -W clippy::redundant_pattern \
    -W clippy::redundant_guards
  ```

### Rust Analyzer

[`rust-analyzer`](https://github.com/rust-lang/rust-analyzer)
([home](https://rust-analyzer.github.io/)) is an implementation of Language
Server Protocol for the Rust programming language.

### Rust Code Format Checker

[`rustfmt`](https://rust-lang.github.io/rustfmt/)
([repo](https://github.com/rust-lang/rustfmt)) formats a Rust code using the
Rust code style conventions.

* To check the code style of one file, type:
  ```sh
  $ rustfmt --check file.rs
  ```

> [!NOTE]
> `rustfmt` is deprecated. Use `cargo fmt` instead.

### Rust Compiler

[`rustc`](https://doc.rust-lang.org/rustc/index.html) compiles a rust project
into its binary representation.

* To compile a Rust project, type:
  ```sh
  $ rustc main.rs
  ```
  All you need is just to pass your project's root file to `rustc` (here
  `main.rs`) and `rustc` will automatically gather all the necessary source
  files, compiles them and links them together.
* To demangle Rust symbol names, use
  [`rustfilt`](https://github.com/luser/rustfilt)
  ([documentation](https://docs.rs/crate/rustfilt/latest),
  [crate](https://crates.io/crates/rustfilt)).

Useful compiler configuration:
* `cargo` release profile (see [this comment](https://github.com/tauri-apps/tauri/issues/6538#issue-1638776512)):
  ```toml
  [profile.release]
  panic = "abort"   # Strip expensive panic clean-up logic
  codegen-units = 1 # Compile crates one after another so the compiler can optimize better
  lto = true        # Enables link to optimizations
  # opt-level = "s"   # Optimize for binary size (may produce slower binaries)
  strip = true      # Remove debug symbols
  ```
* stripping local user name (see [this comment](https://github.com/tauri-apps/tauri/issues/6538#issuecomment-1482634473)):
  ```bash
  RUSTFLAGS+=" --remap-path-prefix=${HOME}/my_projects/my_rust_project=my_rust_project"
  RUSTFLAGS+=" --remap-path-prefix=${HOME}/.cargo={HOME}/.cargo"
  RUSTFLAGS+=" --remap-path-prefix=${HOME}/.rustup={HOME}/.rustup"
  ```

#### Caching

* [[Idea] Precompiled dependencies](https://internals.rust-lang.org/t/idea-precompiled-dependencies/15602)
* [Is a shared build cache a good fit for Cargo?](https://internals.rust-lang.org/t/is-a-shared-build-cache-a-good-fit-for-cargo/)
* [`sccache` - shared compilation cache](https://github.com/mozilla/sccache) [[doc](https://docs.rs/sccache/latest/sccache/)] [[crate](https://crates.io/crates/sccache)]

#### CI & Code Coverage

Examples:
* [atty](https://github.com/softprops/atty)
* [fantoccini](https://github.com/jonhoo/fantoccini)
* [Rust CI with GitHub Actions](https://github.com/BamPeers/rust-ci-github-actions-workflow)
* [Tantivy](https://github.com/quickwit-oss/tantivy)

References:
* [Can I include debug information only for my code without packages?](https://stackoverflow.com/questions/58627230/can-i-include-debug-information-only-for-my-code-without-packages)
* [Can tests be built in release mode using Cargo?](https://stackoverflow.com/questions/29818084/can-tests-be-built-in-release-mode-using-cargo)
* [Demystifying the profraw format](https://leodido.dev/demystifying-profraw/)
* [How to do code coverage in Rust](https://blog.rng0.io/how-to-do-code-coverage-in-rust)
* [Instrumentation-based Code Coverage](https://doc.rust-lang.org/rustc/instrument-coverage.html)
* [LLVM-COV - Warnings of "X functions have mismatched data" and missing coverage data in reports](https://github.com/llvm/llvm-project/issues/72786)
* ["Mismatched function data" warnings when collecting profiles for clang](https://github.com/llvm/llvm-project/issues/32849)
* [Rust profiling in Red Hat Enterprise Linux 9.3 and 8.9](https://www.redhat.com/en/blog/rust-profiling-in-rhel)
* [Source-based Code Coverage](https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html#source-based-code-coverage)
  * [LLVM Source-Based Code Coverage](https://rustc-dev-guide.rust-lang.org/llvm-coverage-instrumentation.html)
* [Tips for Faster Rust CI Builds](https://corrode.dev/blog/tips-for-faster-ci-builds/)
* [Upstream Issues](https://github.com/rust-lang/rust/labels/A-code-coverage)
  * [coverage: Don't instrument `#[automatically_derived]` functions](https://github.com/rust-lang/rust/pull/120185)
* [Which files from the target directory are actually required by the executable?](https://stackoverflow.com/questions/47528244/which-files-from-the-target-directory-are-actually-required-by-the-executable)

Tools:
* [cargo-llvm-cov](https://github.com/taiki-e/cargo-llvm-cov) [[doc](https://docs.rs/cargo-llvm-cov/latest/cargo_llvm_cov/)] [[crate](https://crates.io/crates/cargo-llvm-cov)]
* [grcov](https://github.com/mozilla/grcov) [[doc](https://docs.rs/grcov/latest/grcov/)] [[crate](https://crates.io/crates/grcov)]
* [kcov](https://github.com/SimonKagstrom/kcov)
* [rust-ci-conf](https://github.com/jonhoo/rust-ci-conf)
* [Tarpaulin](https://github.com/xd009642/tarpaulin) [[doc](https://docs.rs/cargo-tarpaulin/latest/cargo_tarpaulin/)] [[crate](https://crates.io/crates/cargo-tarpaulin)]

#### Dynamic Linking

* [Is there a way to dynamic link with all dependencies?](https://www.reddit.com/r/rust/comments/11xc6c4/is_there_a_way_to_dynamic_link_with_all/)

#### GitHub Actions

* [Rust Cache Action](https://github.com/Swatinem/rust-cache)

### Miri

[Miri](https://github.com/rust-lang/miri) is a mid-level intermediate
representation interpreter. It can run Rust programs and detect certain classes
of undefined behavior.

### Nextest

[Nextest](https://github.com/nextest-rs/nextest)
([documentation](https://nexte.st/)) is a next generation test runner for Rust.

### `rstest`

[`rstest`](https://github.com/la10736/rstest/)
([documentation](https://docs.rs/rstest/latest/rstest/),
[crate](https://crates.io/crates/rstest)) is a fixture-based test
framework for Rust.

Video: [Mastering Testing in Rust Using Rstest](https://www.youtube.com/watch?v=w10ndWcuflo)

### Rudra

[Rudra](https://github.com/sslab-gatech/Rudra) is a static analyzer to detect
common undefined behaviors in Rust programs.

### Yuga

[Yuga](https://github.com/vnrst/Yuga) is an automatic lifetime annotation bugs
detector
([article](https://research.redhat.com/blog/article/yuga-a-tool-to-help-rust-developers-write-unsafe-code-more-safely/)).

## Lexical Elements

Grammar:
```
token:
    keyword
    weak_keyword
    identifier
    char_literal
    byte_literal
    string_literal
    raw_string_literal
    byte_string_literal
    raw_byte_string_literal
    integer_literal
    float_literal
    lifetime_token
    lifetime_or_label
    punctuation
    delimiters
    reserved_token_double_quote
    reserved_token_single_quote
    reserved_token_pound

lifetime_token:
    "'" identifier_or_keyword
    "'" "_"
lifetime_or_label:
    "'" non_keyword_identifier

punctuation:
    "+" | "-" | "*" | "/" | "%" | "^" | "!" | "&" | "|" | "&&" | "||" | "<<"
    ">>" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<="
    ">>=" | "=" | "==" | "!=" | ">" | "<" | ">=" | "<=" | "@" | "_" | "."
    ".." | "..." | "..=" | "," | ";" | ":" | "::" | "->" | "=>" | "#" | "$"
    "?" | "~"
delimiters:
    "(" | ")" | "[" | "]" | "{" | "}"

reserved_token_double_quote:
    ((identifier_or_keyword - ("b" | "r" | "br")) | "_") '"'
reserved_token_single_quote:
    ((identifier_or_keyword - "b") | "_") "'"
reserved_token_pound:
    ((identifier_or_keyword - ("r" | "br")) | "_") "#"

reserved_number:
    bin_literal ("2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")
    oct_literal ("8" | "9")
    (bin_literal | oct_literal | hex_literal)
        "."{not-followed-by ("." | "_" | <XID start Unicode character>)}
    (bin_literal | oct_literal) ("e" | "E")
    "0b" "_"* (<end of input> | !bin_digit)
    "0o" "_"* (<end of input> | !oct_digit)
    "0x" "_"* (<end of input> | !hex_digit)
    dec_literal ("." dec_literal)? ("e" | "E") ("+" | "-")?
        (<end of input> | !dec_digit)

suffix:
    identifier_or_keyword
suffix_no_e:
    suffix - (("e" | "E").*)
isolated_cr:
    <a U+000D not followed by a U+000A>

utf8bom:
    U+FEFF
shebang:
    "#!" (!U+000A)+
```
* Rust input is viewed as a sequence of UTF-8 characters
* a `reserved_number` is rejected by the tokenizer instead of tokenized to
  separate tokens
* see [Tokens](https://doc.rust-lang.org/reference/tokens.html) for greater
  detail

### Whitespace

Grammar:
```
whitespace:
    U+0009  # horizontal tab
    U+000A  # line feed
    U+000B  # vertical tab
    U+000C  # form feed
    U+000D  # carriage return
    U+0020  # space
    U+0085  # next line
    U+200E  # left-to-right mark
    U+200F  # right-to-left mark
    U+2028  # line separator
    U+2029  # paragraph separator
    <unicode character that have the pattern white space property>
```
* `whitespace` characters are ignored
* see [Whitespace](https://doc.rust-lang.org/reference/whitespace.html) for
  greater detail

### Comments

Grammar:
```
line_comment:
    "//" (!("/" | "!" | U+000A) | "//") (!U+000A)*
    "//"
block_comment:
    "/*" (!("*" | "!") | "**" | block_comment_or_doc)
        (block_comment_or_doc | !"*/")*
        "*/"
    "/**/"
    "/***/"
inner_line_doc:
    "//!" (!(U+000A | isolated_cr))*
inner_block_doc:
    "/*!" (block_comment_or_doc | !("*/" | isolated_cr))* "*/"
outer_line_doc:
    "///" (!"/" (!(U+000A | isolated_cr))*)?
outer_block_doc:
    "/**" (!"*" | block_comment_or_doc)
        (block_comment_or_doc | !("*/" | isolated_cr))*
        "*/"

block_comment_or_doc:
    block_comment
    outer_block_doc
    inner_block_doc
```
* comments are ignored by `rustc` but not by particular tools (`cargo doc`
  etc.)

Examples:
```rust
// This is a single line comment.

/*
 * This is a block comment.
 */

//! This inner doc line comment.

/*!
 * This is inner doc block comment.
 */

/// This is outer doc line comment.

/**
 * This is outer doc block comment.
 */
```

See [Comments](https://doc.rust-lang.org/reference/comments.html) for greater
detail.

### Keywords

Grammar:
```
keyword:
    "as" | "break" | "const" | "continue" | "crate" | "else" | "enum"
    "extern" | "false" | "fn" | "for" | "if" | "impl" | "in" | "let"
    "loop" | "match" | "mod" | "move" | "mut" | "pub" | "ref" | "return"
    "self" | "Self" | "static" | "struct" | "super" | "trait" | "true"
    "type" | "unsafe" | "use" | "where" | "while"
    # 2018+:
    "async" | "await" | "dyn"
    # Reserved:
    "abstract" | "become" | "box" | "do" | "final" | "macro" | "override"
    "priv" | "typeof" | "unsized" | "virtual" | "yield"
    # 2018+:
    "try"
weak_keyword:
    "macro_rules" | "union" | "'static"
    # 2015:
    "dyn"
```

See [Appendix A: Keywords](https://doc.rust-lang.org/book/appendix-01-keywords.html)
from the [book](https://doc.rust-lang.org/book/) or [Keywords](https://doc.rust-lang.org/reference/keywords.html)
for greater detail.

### Identifiers

Grammar:
```
identifier_or_keyword:
    <XID start Unicode character> <XID continue Unicode character>*
    "_" <XID continue Unicode character>+
raw_identifier:
    "r#" (identifier_or_keyword - ("crate" | "self" | "super" | "Self"))
non_keyword_identifier:
    identifier_or_keyword - keyword

identifier:
    non_keyword_identifier
    raw_identifier
```

See [Identifiers](https://doc.rust-lang.org/reference/identifiers.html) for
greater detail.

### Literals

* any literal may end with suffix which is an identifier or keyword
* a suffix can annotate a literal with type or it can serve as syntactical
  sugar in token stream processed during macro expansion

#### Character Literals

Grammar:
```
char_literal:
    "'" (
        !("'" | r"\" | U+000A | U+000D | U+0009) |
        quote_escape | ascii_escape | unicode_escape
    ) "'" suffix?

quote_escape:
    r"\'" | r'\"'
ascii_escape:
    r"\x" oct_digit hex_digit
    r"\n" | r"\r" | r"\t" | r"\\" | r"\0"
unicode_escape:
    r"\u{" (hex_digit "_"*){1,6} "}"
```
* a character between quotes is any Unicode Scalar Value (U+0000 to U+D7FF and
  U+E000 to U+10FFFF inclusive) except single quote (U+0027), backslash
  (U+005C), new line (U+000A), carriage return (U+000D), and tab character
  (U+0009)
* the type of character literal is `chr`
* see [Character literals](https://doc.rust-lang.org/reference/tokens.html#character-literals)
  for greater detail

#### String Literals

Grammar:
```
string_literal:
    '"' (
        !('"' | r"\" | isolated_cr) |
        quote_escape | ascii_escape | unicode_escape | string_continue
    )* '"' suffix?
string_continue:
    <r"\" followed by U+000A>

raw_string_literal:
    "r" raw_string_content suffix?
raw_string_content:
    '"' (!isolated_cr){non-greedy *} '"'
    "#" raw_string_content "#"

byte_string_literal:
    'b"' (
        ascii_for_string | byte_escape | string_continue
    )* '"' suffix?
ascii_for_string:
    <any ASCII (i.e. '\0' to '\x7f'), except '"', '\\' and isolated_cr>

raw_byte_string_literal:
    "br" raw_byte_string_content suffix?
raw_byte_string_content"
    '"' ascii{non-greedy *} '"'
    "#" raw_byte_string_content "#"
ascii:
    <any ASCII (i.e. '\0' to '\x7f')>
```
* a character in a `string_literal` is any Unicode Scalar Value (U+0000 to
  U+D7FF and U+E000 to U+10FFFF inclusive) except double quote (U+0022),
  backslash (U+005C), and sole carriage return (U+000D); U+000D U+000A is
  translated to U+000A
* in a `string_literal`, if `(U+000D? U+000A)` immediatelly follows a backslash
  character, then the backslash character, the `(U+000D? U+000A)` and the
  following string containing only U+0020, U+000A, U+000D and U+0009 characters
  are removed from the `string_literal`
* a character in a `raw_string_literal` is any Unicode Scalar Value (U+0000 to
  U+D7FF and U+E000 to U+10FFFF inclusive) except sole carriage return (U+000D)
* `raw_string_literal` and `raw_byte_string_literal` do not process any escape
  sequence
* the type of string literal is `&'static str`
* the type of byte string literal of the length `n` is `&'static [u8; n]`
* see [String literals](https://doc.rust-lang.org/reference/tokens.html#string-literals),
  [Raw string literals](https://doc.rust-lang.org/reference/tokens.html#raw-string-literals),
  [Byte string literals](https://doc.rust-lang.org/reference/tokens.html#byte-string-literals),
  and [Raw byte string literals](https://doc.rust-lang.org/reference/tokens.html#raw-byte-string-literals)
  for greater detail

#### Integer Literals

Grammar:
```
byte_literal:
    "b'" (ascii_for_char | byte_escape) "'" suffix?
ascii_for_char:
    <any ASCII (i.e. '\0' to '\x7f') except '\'', '\\', '\n', '\r' or '\t'>
byte_escape:
    r"\x" hex_digit hex_digit
    r"\n" | r"\r" | r"\t" | r"\\" | r"\0" | r"\'" | r'\"'

integer_literal:
    dec_literal suffix_no_e?
    bin_literal suffix_no_e?
    oct_literal suffix_no_e?
    hex_literal suffix_no_e?

dec_literal:
    dec_digit (dec_digit | "_")*
bin_literal:
    "0b" (bin_digit | "_")* bin_digit (bin_digit | "_")*
oct_literal:
    "0o" (oct_digit | "_")* oct_digit (oct_digit | "_")*
hex_literal:
    "0x" (hex_digit | "_")* hex_digit (hex_digit | "_")*

bin_digit:
    "0" | "1"
oct_digit:
    bin_digit | "2" | "3" | "4" | "5" | "6" | "7"
dec_digit:
    oct_digit | "8" | "9"
hex_digit:
    dec_digit
    "a" | "b" | "c" | "d" | "e" | "f"
    "A" | "B" | "C" | "D" | "E" | "F"
```
* `_` works as a digit separator and is ignored (increases number readability)
* after macro expansion, `suffix` should be one of `u8`, `i8`, `u16`, `i16`,
  `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `usize` or `isize`
  * `byte_literal` `suffix` should be `u8`
* if there is no type suffix, `i32` is used
* see [Byte literals](https://doc.rust-lang.org/reference/tokens.html#byte-literals),
  [Integer literals](https://doc.rust-lang.org/reference/tokens.html#integer-literals)
  and [Integer literal expressions](https://doc.rust-lang.org/reference/expressions/literal-expr.html#integer-literal-expressions)
  for greater detail

#### Floating Point Literals

Grammar:
```
float_literal:
    dec_literal "."{not-followed-by ("." | "_" | <XID start Unicode character>)}
    dec_literal "." dec_literal suffix_no_e?
    dec_literal ("." dec_literal)? float_exponent suffix?

float_exponent:
    ("e" | "E") ("+" | "-")? (dec_digit | "_")* dec_digit (dec_digit | "_")*
```
* after macros are expanded, `suffix` should be either `f32` or `f64`
* if there is no type suffix, `f64` is used
* see [Floating-point literals](https://doc.rust-lang.org/reference/tokens.html#floating-point-literals)
  and [Floating-point literal expressions](https://doc.rust-lang.org/reference/expressions/literal-expr.html#floating-point-literal-expressions)
  for greater detail

## Data Types

Grammar:
```
type:
    type_no_bounds
    impl_trait_type
    trait_object_type

type_no_bounds:
    parenthesized_type
    impl_trait_type_one_bound
    trait_object_type_one_bound
    type_path
    tuple_type
    never_type
    raw_pointer_type
    reference_type
    array_type
    slice_type
    inferred_type
    qualified_path_in_type
    bare_function_type
    macro_invocation

parenthesized_type:
    "(" type ")"
```
* Rust can infer a variable's data type
  * in case of more than one possible data types, a variable must be annotated
    with a data type

### Layout

* the layout of a type consists of
  * its size
  * its alignment
  * the relative offsets of its fields
  * the layout and interpretation of discriminant (`enum`s only)
* types with the same layout can still differ in how they are passed across
  function boundaries
* the *alignment* of a value specifies what addresses are valid to store the
  value at
  * a value of alignment `n` must only be stored at an address that is a
    multiple of `n`
  * measured in bytes
  * must be a power of 2 and at least 1
  * the function `align_of_val` returns the minimum alignment required for the
    type of the given value
* the *size* of a value is the offset in bytes between successive elements in
  an array with that item type including alignment padding
  * always a multiple of value's alignment
  * some types are zero-sized
  * the function `size_of_val` returns the size of a value in bytes
* a type where all its values have the same size and same alignment
  * implements the `Sized` trait
  * the size in bytes of such a type can be obtained via the `size_of` function
  * the minimum alignment required for such a type can be obtained via the
    `align_of` function
* see [Type Layout](https://doc.rust-lang.org/reference/type-layout.html),
  [ABI compatibility](https://doc.rust-lang.org/core/primitive.fn.html#abi-compatibility),
  [Dynamically Sized Types](https://doc.rust-lang.org/reference/dynamically-sized-types.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`align_of`](https://doc.rust-lang.org/std/mem/fn.align_of.html),
  [`align_of_val`](https://doc.rust-lang.org/std/mem/fn.align_of_val.html),
  [`size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html), and
  [`size_of_val`](https://doc.rust-lang.org/std/mem/fn.size_of_val.html) for
  greater detail

### Never Type

Grammar:
```
never_type:
    "!"
```
* `!`
* has no values
* represent the result of computations that never complete
* can be coerced into any other type
* can only appear in function return types
* see [Never type](https://doc.rust-lang.org/reference/types/never.html) for
  greater detail

### Scalar Types

#### Boolean Type

* `bool`
* one byte in size
  * the single byte of a `bool` is guaranteed to be initialized
* alignment on one byte boundary
* two possible values: `true` (bit pattern `0x01`) and `false` (bit pattern
  `0x00`)
  * other values (bit patterns) may result in undefined behavior
* implements [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits
* operations table:
  | `a` | `b` | `!b` | `a \| b` | `a & b` | `a ^ b` | `a == b` | `a > b` |
  | --- | --- | ---- | -------- | ------- | ------- | -------- | ------- |
  | `false` | `false` | `true` | `false` | `false` | `false` | `true` | `false` |
  | `false` | `true` | `false` | `true` | `false` | `true` | `false` | `false` |
  | `true` | `false` | `true` | `true` | `false` | `true` | `false` | `true` |
  | `true` | `true` | `false` | `true` | `true` | `false` | `true` | `false` |
* other operations:
  * `a != b` is defined as `!(a == b)`
  * `a >= b` is defined as `a == b | a > b`
  * `a < b` is defined as `!(a >= b)`
  * `a <= b` is defined as `a == b | a < b`
* see [Boolean type](https://doc.rust-lang.org/reference/types/boolean.html)
  for greater detail

#### Character Type

* `char`
* a value of type `char` is a Unicode scalar value
  * 32-bit unsigned word
    * have the same size and alignment as `u32`
  * range `0x0000` to `0xD7FF` or `0xE000` to `0x10FFFF`
    * `char` outside of this range has undefined behavior
* every byte of a `char` is guaranteed to be initialized
* a `[char]` is effectively a UCS-4/UTF-32 string of length 1
* implements [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits
* see [Textual types](https://doc.rust-lang.org/reference/types/textual.html)
  for greater detail

#### Integer Types

| **Signed** | **Unsigned** | **Size** |
| ---------- | ------------ | -------- |
| `i8` | `u8` | 8 bits |
| `i16` | `u16` | 16 bits |
| `i32` | `u32` | 32 bits |
| `i64` | `u64` | 64 bits |
| `i128` | `u128` | 128 bits |
| `isize` | `usize` | machine specific |

* `usize` has the same number of bits as the platform's pointer type
  * at least 16 bits wide
* `isize` has the same number of bits as the platform's pointer type
  * at least 16 bits wide
  * maximum `isize` value is the theoretical upper bound on object and array
    size
* alignment of integer types is platform-specific
  * in most cases, their alignment is equal to their size, but it may be less
* range (`2**x` means `1 << x`):
  * `iN` (`N` bits, signed):
    * minimum: `-(2**(N-1))`
    * maximum: `2**(N-1) - 1`
  * `uN` (`N` bits, unsigned):
    * minimum: `0`
    * maximum: `2**N - 1`
* for every integer type `T`
  * the bit validity of `T` is equivalent to the bit validity of
    `[u8; size_of::<T>()]`
* an uninitialized byte is not a valid `u8`
* every integer type implements
  [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits

See [Integer types](https://doc.rust-lang.org/reference/types/numeric.html#integer-types),
[Type Layout](https://doc.rust-lang.org/reference/type-layout.html), and
[Machine-dependent integer types](https://doc.rust-lang.org/reference/types/numeric.html#machine-dependent-integer-types)
for greater detail.

#### Floating Point Types

* `f32` and `f64` with 32 bits and 64 bits in size, respectively
* alignment of floating point types is platform-specific
  * in most cases, their alignment is equal to their size, but it may be less
* IEEE 754-2008
* default is `f64`
* for every floating point type `T`
  * the bit validity of `T` is equivalent to the bit validity of
    `[u8; size_of::<T>()]`
* every floating point type implements
  [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits
* see [Floating-point types](https://doc.rust-lang.org/reference/types/numeric.html#floating-point-types)
  and [Type Layout](https://doc.rust-lang.org/reference/type-layout.html) for
  greater detail

### Compound Types

* a user-defined compound type, that is an `enum`, `struct`, or `union`, has
  the layout specified by a *representation*
  * the representation of a type can change the padding between fields, but
    does not change the layout of the fields themselves
* there are four kinds of representations:
  * the `Rust` representation (default)
  * the `C` representation
  * the primitive representations
  * the `transparent` representation
* the `repr` attribute
  * changes the representation
  * can only be applied on `enum`, `struct`, or `union`
  * when missing, the default (`Rust`) is used
* the `repr` attribute's alignment modifiers
  * usage: `#[repr(C, align(8))]`, `#[repr(packed)]`
  * for `struct`s and `union`s only
    * `align` can also be applied on an `enum`
  * `align` and `packed`
    * may only be applied to the `Rust` and `C` representations
    * cannot be applied on the same type
    * `packed` type cannot transitively contain another `align`ed type
  * argument to `align` and `packed` must be a power of two from 1 up to
    `2**29`
  * `align(n)` raises the alignment to `n` bytes
    * if `n` is less than the alignment of the type without the `align`
      modifier, then the alignment is unaffected
    * alignment of `#[repr(..., align(n))] enum X { ... }` is the same as the
      alignment of `enum X { ... } #[repr(..., align(n))] struct Y(X)`
  * `packed(n)` lowers the alignment to `n` bytes
    * `packed` is the shorthand for `packed(1)`
    * may alter the padding between fields
      * will not alter the padding inside of any field
    * if `n` is greater than the type's alignment without the `packed`
      modifier, then the alignment and layout is unaffected
    * references to `packed` (unaligned) fields are not allowed due to
      undefined behavior
  * the alignments of each field, for the purpose of positioning fields, is the
    smaller of the specified alignment and the alignment of the field's type
  * inter-field padding is guaranteed to be the minimum required in order to
    satisfy each field's (possibly altered) alignment
    * as a consequence, `packed(1)` will have no inter-field padding
* the `Rust` representation provides only these data layout guarantees:
  * the fields are properly aligned
    * the offset of any field is divisible by that field's alignment
  * the fields do not overlap
    * the fields can be ordered such that the offset plus the size of any field
      is less than or equal to the offset of the next field in the ordering
    * the ordering may differ from the order of the fields in the type's
      declaration
    * zero-sized types may have the same address as other fields in the same
      `struct`
  * the alignment of the type is at least the maximum alignment of its fields
* the `C` representation serves dual purpose:
  * creating types that are interoperable with the C Language
  * to create types on which operations that rely on data layout can be soundly
    performed
    * such operations could be for example reinterpreting values as a different
      type
    * note that it is possible to create types that are not useful for
      interfacing with the C programming language
  * cannot be applied to zero-variant `enum`s
* the primitive representations
  * have the same names as the primitive integer types: `i8`, `u8`, `i16`,
    `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, and `usize`
  * can only be applied to `enum`s, except zero-variant `enum`s
  * a primitive representation cannot be combined together with another
    primitive representation
* the `transparent` representation
  * delegates type layout to another type
  * cannot be used with any other representation
  * can only be used on a `struct` or an `enum` with a single variant that has
    * any number of fields with size 0 and alignment 1, and
    * at most one other field
  * impose the same layout and ABI as the only non-size 0 non-alignment 1
    field, if present, or unit otherwise
    * e.g. a `struct` with the `transparent` representation with a primitive
      field will have the ABI of the primitive field
* see [Type Layout](https://doc.rust-lang.org/reference/type-layout.html),
  [Structs](https://doc.rust-lang.org/reference/items/structs.html),
  [Enumerations](https://doc.rust-lang.org/reference/items/enumerations.html),
  and [Behavior considered undefined](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)
  for greater detail

#### String Type

* `str`
* dynamically sized type
  * it can only be instantiated through a pointer type, such as `&str`
* a value of type `str` has the same representation and layout as `[u8]`
* methods working on `str` ensure and assume that the data in there is valid
  UTF-8
  * calling a `str` method with a non-UTF-8 buffer can cause undefined behavior
* `&str` is not indexable
* a slice of `&str` outside of character boundaries make a Rust program to
  panic
  * a slice operation is performed over bytes, not characters
  * a character boundary is where the last byte of the character ends and the
    first byte of the next character begins (recall that characters are UTF-8
    encoded)
* implements [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits
* see [Textual types](https://doc.rust-lang.org/reference/types/textual.html),
  [Type Layout](https://doc.rust-lang.org/reference/type-layout.html),
  and [Dynamically Sized Types](https://doc.rust-lang.org/reference/dynamically-sized-types.html)
  for greater detail

#### Tuple Types

Grammar:
```
tuple_type:
    "(" ")"
    "(" (type ",")+ type? ")"
```
* tuples are finite sequences of values, where two values may have distinct
  types
* tuple types, except the unit, have layout according to the Rust
  representation
* an item can be either type or expression or identifier
* an example of assigning a tuple to the variable:
  ```rust
  let tup = ("foo", 1, 0.5);
  ```
* with type annotations:
  ```rust
  let tup: (str, i32, f64) = ("foo", 1, 0.5);
  ```
* elements can be extracted from a tuple using either dot expression or
  destructuring assignment
* dot expression has a form `tuple "." index`, where `index` is a non-negative
  integer literal in decimal notation not exceeding the tuple size minus one
  (tuple indices are zero-based); example:
  ```rust
  let point = (3, 5);

  let x = point.0;
  let y = point.1;
  ```
* destructuring assignment:
  ```rust
  let point = (3, 5);

  let (x, y) = point;
  ```
* a tuple type implements
  [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits if its
  underlying types implement these

##### Unit

* *empty tuple*
* zero-sized type
  * has a size of 0 and an alignment of 1
* both unit type and unit value are written as `()`
* represent an empty value or an empty return type
* empty value is returned implicitly by an expression
* implements [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits

See [Tuple types](https://doc.rust-lang.org/reference/types/tuple.html),
[Tuple and tuple indexing expressions](https://doc.rust-lang.org/reference/expressions/tuple-expr.html),
and [Type Layout](https://doc.rust-lang.org/reference/type-layout.html) for
greater detail.

#### Array Types

Grammar:
```
array_type:
    "[" type ";" expression "]"
```
* arrays are finite sequences of values of same type
* an array of `[T; N]`
  * has a size of `size_of::<T>() * N`
  * has the same alignment of `T`
  * the zero-based `n`th element of the array is offset from the start of the
    array by `n * size_of::<T>()` bytes
* unlike in other programming languages arrays have fixed length
  * the size of an array is specified by `expression`, which must be a constant
    expression that evaluates to `usize`
* in Rust, array are allocated on stack
* all elements of an array are always initialized
* an example of an array assigned to the variable:
  ```rust
  let arr = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  ```
* with type annotation specified:
  ```rust
  let arr: [u8; 4] = [1, 2, 4, 8];
  ```
* arrays can be initialized by `"[" value ";" count "]"` expression:
  ```rust
  let arr = [2; 4];  // same as `let arr = [2, 2, 2, 2];`
  ```
* to access the element of an array, use `array "[" index "]"` expression:
  ```rust
  let arr = ["a", "b"];

  let a = arr[0];  // a == "a"
  let b = arr[1];  // b == "b"
  ```
* like tuples, array indices are zero-based
* indexing an array out of its bounds make a program panicking
* see [Array types](https://doc.rust-lang.org/reference/types/array.html),
  [Array and array index expressions](https://doc.rust-lang.org/reference/expressions/array-expr.html),
  and [Type Layout](https://doc.rust-lang.org/reference/type-layout.html) for
  greater detail

#### Slice Types

Grammar:
```
slice_type:
    "[" type "]"
```
* dynamically sized type
* a slice `[T]` has the same layout as the section of the array it slices
* represents a view into a sequence of elements of some type
* generally used through pointer types
* all elements of a slice are always initialized
* access to a slice is always bounds-checked in safe methods and operators
* see [Slice types](https://doc.rust-lang.org/reference/types/slice.html)
  and [Type Layout](https://doc.rust-lang.org/reference/type-layout.html) for
  greater detail

#### Struct Types

* a `struct` type is a heterogeneous product of other types
* `struct`s have no specified memory layout, the default is `Rust`
  * to specify one, use [`repr`](https://doc.rust-lang.org/reference/type-layout.html#representations)
    attribute
  * the size, alignment, and layout of a `struct` under `#[repr(C)]` is given
    by the following algorithm (can produce a zero-sized `struct`s which are
    illegal in the C programming language):
    ```js
    function padding(offset, alignment) {
        return (alignment - (offset % alignment)) % alignment;
    }

    // Adjust the size, the alignment, and the offset of the fields of
    // `struct`.
    //
    // Members of `struct`:
    //   * `fields` - the list of `struct` fields in order as they appear in
    //                the `struct` declaration
    //   * `alignment` - the `struct`'s alignment
    //   * `size` - the `struct`'s size
    //
    // Members of an item from `struct.fields`:
    //   * `alignment` - the `struct` field alignment
    //   * `offset` - the `struct` field offset within the `struct`
    //   * `size` - the `struct` field size
    //
    // The alignment of `struct` is the alignment of one of its fields with the
    // biggest alignment. The offset of each field is adjusted so that the
    // offset of a field is a multiple of the field's alignment. The size of
    // `struct` is the size of all its fields, including padding, plus
    // additional padding needed to make the size of `struct` to be a multiple
    // of `struct`'s alignment.
    function adjust_struct(struct) {
        let offset = 0;

        struct.alignment = Math.max(
            1, ...struct.fields.map((field) => field.alignment)
        );
        for (let field of struct.fields) {
            offset += padding(offset, field.alignment);
            field.offset = offset;
            offset += field.size;
        }
        struct.size = offset + padding(offset, struct.alignment);
    }
    ```
* visibility of a `struct`'s fields can be specified
* a tuple `struct` type has anonymous fields
* a unit-like `struct` type has no fields
* a `struct` type can implement
  [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits if
  types of its fields implement these
  * a unit-like `struct` type can implement all of these
* see [Struct types](https://doc.rust-lang.org/reference/types/struct.html),
  [Type Layout](https://doc.rust-lang.org/reference/type-layout.html), and
  [Visibility and Privacy](https://doc.rust-lang.org/reference/visibility-and-privacy.html)
  for greater detail

#### Enumerated Types

* nominal, heterogeneous disjoint union types
* any `enum` value consumes as much memory as the largest variant for its
  corresponding `enum` type plus the size of discriminant
* the layout under `#[repr(C)]`
  * field-less `enum`s
    * have the size and alignment of the default `enum` size and alignment for
      the target platform's C ABI
    * the `enum` representation in C is implementation defined and can be
      influenced by compiler flags, which may cause ABI break
    * using a field-less `enum` in FFI to model a C `enum` is often wrong
  * an `enum` with fields has the same layout as a `struct` with two fields
    under `#[repr(C)]`, a.k.a. *tagged union* in C
    * the first field is the *tag*: a `#[repr(C)]` version of the `enum` with
      all fields removed
    * the second field is the *payload*: a `#[repr(C)]` union of `#[repr(C)]`
      `struct`s for the fields of each variant that had them
* the layout under `#[repr(x)]`, where `x` is a primitive integer type
  * field-less `enum`s
    * the size and alignment of the field-less `enum` is the same as the size
      and the alignment of `x`
  * an `enum` with fields has the same layout as a union under `#[repr(C)]`
    with `struct`s under `#[repr(C)]` as its fields
    * each `struct`-like field reflects the corresponding `enum` variant
      * the first field of the `struct` is the `enum` under `#[repr(x)]` with
        all fields removed (the *tag*)
      * the next fields are the fields of that variant
* the layout under `#[repr(C, x)]`, where `x` is the primitive integer type
  * an `enum` with fields has the same layout as the `enum` under `#[repr(C)]`
    with the same fields, except that the discriminant (the *tag*) is under
    `#[repr(x)]`
* must be denoted by named reference to an `enum` item
* an `enum` type can implement
  [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits if
  types of its variants implement these
  * an `enum` type with no variants or only with unit-like variants can
    implement all of these
* see [Enumerated types](https://doc.rust-lang.org/reference/types/enum.html),
  [Type Layout](https://doc.rust-lang.org/reference/type-layout.html), and
  [Behavior considered undefined](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)
  for greater detail

#### Union Types

* nominal, heterogeneous C-like union
* no notion of an *active field*
  * reading from a `union` field requires `unsafe`
    * since data type transmutation between read/write may result in unexpected
      or undefined behavior
* only types that never need to be dropped can be used for `union` fields
* by default the memory layout of a `union` is undefined
  * the memory layout can be specified by `#[repr(...)]`
  * with `#[repr(C)]`
    * unions will have the same size and alignment as their C language
      equivalents for the target platform
    * the alignment of the union will be the alignment of its field with the
      biggest alignment
    * the size of the union will be the size of its biggest field plus the
      padding to make the size a multiple of the union alignment
* `union`s with non-`Copy` fields are unstable
* see [Union types](https://doc.rust-lang.org/reference/types/union.html),
  [Unions](https://doc.rust-lang.org/reference/items/unions.html),
  [Type Layout](https://doc.rust-lang.org/reference/type-layout.html), and
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html) for greater
  detail

#### Function Item Types

* zero-sized
* yielded by:
  * a function item
  * a tuple-like `struct` constructor
  * an `enum` variant constructor
* explicitly identifies the function
  * its name
  * its type arguments
  * its early-bound lifetime arguments
* a function item can be coerced to the function pointer with the same
  signature
* implements
  [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),
  [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html),
  [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html), and
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) traits
* see [Function item types](https://doc.rust-lang.org/reference/types/function-item.html),
  [Function pointer types](https://doc.rust-lang.org/reference/types/function-pointer.html),
  and [Type coercions](https://doc.rust-lang.org/reference/type-coercions.html)
  for greater detail

#### Closure Types

* a closure type is unique for every closure value produced by a closure
  expression
  * a closure type is anonymous and cannot be written out
* a closure type has no layout guarantees
* how a compiler defines a new closure type:
  * parse and analyze a closure expression
    * record which and how (mutably/immutably) are the closed-over variables
      used
      * do not take surrounding code into account, that is
        * ignore the lifetimes of involved variables
        * ignore the lifetime of the closure itself
      * are there no closed-over variables?
        * the closure is *non-capturing*
          * can be coerced to the function pointer type with the same signature
    * does it have the `move` keyword?
  * no `move` keyword present
    * try to capture a closed-over variable by immutable borrow first
    * try to capture a closed-over variable by unique immutable borrow, if
      the previous fails
      * special case which occurs when modifying the referent of a mutable
        reference
      * cannot be used anywhere else in the language
      * cannot be written out explicitly
    * try to capture a closed-over variable by mutable borrow, if the previous
      fails
    * finally, try to capture a closed-over variable by move, if all of the
      previous capturing attempts had failed
      * compiler usually complains about missing `move` keyword
    * note that the decision on which capture mode has to be chosen is made on
      how the captured variable is used inside the closure body
  * the `move` keyword is present
    * all closed-over variables are captured by move or copy
      * a copy capture is preferred if a type implements the `Copy` trait
    * this allows the closure to outlive the captured values
  * note that composite types such as structs, tuples, and enums are always
    captured entirely
  * make a new anonymous struct-like type
    * fields of this new struct-like type are captured variables
    * implement [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html)
      trait for this type
    * implement [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html)
      trait for this type
      * indicates that the closure can be called once by consuming ownership of
        the closure
    * does the closure of this type not move out of any captured variables?
      * implement [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html)
        trait for this type
        * indicates that the closure can be called by mutable reference
    * does the closure of this type not mutate or move out of any captured
      variables?
      * implement [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html) trait
        for this type
        * indicates that the closure can be called by shared reference
    * no variable/value captured by unique immutable or mutable reference?
      * all variables/values captured by copy or move implement
        [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait?
        * implement [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html)
          trait for this type
      * all variables/values captured by copy or move implement
        [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html) trait?
        * implement [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html)
          trait for this type
          * the order of cloning of the captured variables is left unspecified
    * all captured variables implement
      [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) trait?
      * implement [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html)
        trait for this type
    * all variables captured by non-unique immutable reference implement
      [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) trait?
      * all variables/values captured by unique immutable or mutable reference,
        copy, or move implement
        [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html) trait?
        * implement [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html)
          trait for this type
* examples:
  ```rust
  let mut v = vec![1, 2, 3];

  // Implement `Fn` (capture by reference):
  let f_a = || { println!("{v}"); };
  // Also implement `Fn` (capture by move, but the immutable reference is used
  // inside the closure's body):
  let f_b = move || { println!("{v}"); };

  // Implement `FnMut` (capture by mutable reference):
  let g_a = || { v.push(4); };
  // Also implement `FnMut` (capture by move, but the mutable reference is used
  // inside the closure's body):
  let g_b = move || { v.push(4); };

  // Implement `FnOnce` (closure uses operation that takes ownership over the
  // borrowed value):
  let h_a = || { drop(v); };
  // Also implement `FnOnce` (capture by move, but the important is what the
  // closure do with the captured value in the closure's body):
  let h_b = move || { drop(v); };

  // Non-capturing closures can be coerced to function pointers:
  let inc: fn(i32) -> i32 = |x| x + 1;

  let mut b = false;
  let mrb = &mut b;

  // Unique immutable capture:
  let mut f = || { *mrb = true; };
  ```
* see [Closure types](https://doc.rust-lang.org/reference/types/closure.html),
  [Closure expressions](https://doc.rust-lang.org/reference/expressions/closure-expr.html),
  [Type Layout](https://doc.rust-lang.org/reference/type-layout.html),
  [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html),
  [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html),
  [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),
  [`Send`](https://doc.rust-lang.org/std/marker/trait.Send.html),
  [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html),
  [`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
  [`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html), and
  [`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html) for greater
  detail

#### Reference Types

Grammar:
```
reference_type:
    "&" lifetime? "mut"? type_no_bounds
```
* have same layout as pointer types
* if `mut` is not present, a reference is called a *shared* reference
  * it points to a memory location owned by some other value
  * prevents direct mutation of the value (exception to this rule is interior
    mutability)
  * there can be any number of shared references to a value
  * a reference type implements `Copy` trait
  * referencing a temporal value keeps it alive during the lifetime of the
    reference itself
* if `mut` is present, a reference is called a *mutable* reference
  * like shared reference, it also points to a memory location owned by some
    other value
  * allows direct mutation of the value
    * the value must not be borrowed yet
  * only one mutable reference per value can exists
  * a mutable reference type does not implement `Copy` trait
* transmutation of a reference type, `R`, to a `[u8; size_of::<R>()]` is not
  valid
* see [References (`&` and `&mut`)](https://doc.rust-lang.org/reference/types/pointer.html#references--and-mut),
  [Interior Mutability](https://doc.rust-lang.org/reference/interior-mutability.html),
  [Temporaries](https://doc.rust-lang.org/reference/expressions.html#temporaries),
  and [Type Layout](https://doc.rust-lang.org/reference/type-layout.html), for
  greater detail

#### Raw Pointer Types

Grammar:
```
raw_pointer_type:
    "*" ("mut" | "const") type_no_bounds
```
* a raw pointer has no safety or liveness guarantees
* `*const T` is an immutable raw pointer to `T`
* `*mut T` is a mutable raw pointer to `T`
* a raw pointer can be copied or dropped
  * these operations have no effect on the life cycle of any other value
* dereferencing a raw pointer is an `unsafe` operation
  * reborrowing: `&*`, `&mut *`
* a raw pointer, `P`, where `P = *const T` or `P = *mut T`, is said
  * *thin* if `T: Sized`
    * has the same size and alignment as `usize`
  * *fat* otherwise
    * this is the case for dynamically sized objects, where the raw pointer
      contains additional data, like a slot to a virtual method table
    * the size and alignment of a fat pointer type is guaranteed to be at least
      equal to the size and alignment of a thin pointer type
* raw pointers are compared by their address
  * additional data are included into comparison in case of fat raw pointers
* `*const` raw pointers can be created directly by
  [`core::ptr::addr_of`](https://doc.rust-lang.org/core/ptr/macro.addr_of.html)
* `*mut` raw pointers can be created directly by
  [`core::ptr::addr_of_mut`](https://doc.rust-lang.org/core/ptr/macro.addr_of_mut.html)
* transmutation of a raw pointer type, `P`, to a `[u8; size_of::<P>()]` is not
  valid
* transmutation of an integer or array of integers to a thin raw pointer is
  always valid
  * the pointer produced by this transmutation may not be dereferenced
* see [Raw pointers (`*const` and `*mut`)](https://doc.rust-lang.org/reference/types/pointer.html#raw-pointers-const-and-mut),
  [Unsafety](https://doc.rust-lang.org/reference/unsafety.html),
  [Type Layout](https://doc.rust-lang.org/reference/type-layout.html),
  [Dynamically Sized Types](https://doc.rust-lang.org/reference/dynamically-sized-types.html),
  [`core::ptr::addr_of`](https://doc.rust-lang.org/core/ptr/macro.addr_of.html),
  and [`core::ptr::addr_of_mut`](https://doc.rust-lang.org/core/ptr/macro.addr_of_mut.html)
  for greater detail

#### Function Pointer Types

Grammar:
```
bare_function_type:
    for_lifetimes? function_type_qualifiers
        "fn" "(" function_parameters_maybe_named_variadic? ")"
        bare_function_return_type?

function_type_qualifiers:
    "unsafe"? ("extern" abi?)?

bare_function_return_type:
    "->" type_no_bounds

function_parameters_maybe_named_variadic:
    maybe_named_function_parameters
    maybe_named_function_parameters_variadic

maybe_named_function_parameters:
    maybe_named_param ("," maybe_named_param)* ","?

maybe_named_function_parameters_variadic:
    (maybe_named_param ",")* maybe_named_param "," outer_attribute* "..."

maybe_named_param:
    outer_attribute* ((identifier | "_") ":")? type
```
* a function pointer type
  * has the same size and alignment as `usize`
  * refers to a function whose identity is not necessarily known at compile
    time
  * can be created via a type coercion from
    * a function item
    * a non-capturing closure
* `unsafe` qualifier denotes an unsafe function
* `extern` qualifier denotes an extern function
  * only extern function types with `C` or `cdecl` calling convention allow
    variadic parameters
* attributes on function pointer parameters have the same rules and
  restrictions like regular function parameters
* see [Function pointer types](https://doc.rust-lang.org/reference/types/function-pointer.html),
  [Function item types](https://doc.rust-lang.org/reference/types/function-item.html),
  [Closure types](https://doc.rust-lang.org/reference/types/closure.html),
  [Type Layout](https://doc.rust-lang.org/reference/type-layout.html),
  [The `unsafe` keyword](https://doc.rust-lang.org/reference/unsafe-keyword.html),
  [Extern function qualifier](https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier),
  [External blocks](https://doc.rust-lang.org/reference/items/external-blocks.html),
  and [Attributes on function parameters](https://doc.rust-lang.org/reference/items/functions.html#attributes-on-function-parameters)
  for greater detail

#### Type Parameters

If an item has type parameters:
* within the item body, every type parameter acts as a type

#### Inferred Type

Grammar:
```
inferred_type:
    "_"
```
* asks the compiler to infer the type if possible
* cannot be used in item signatures

### Subtyping

`T_a` is a subtype of `T_b` if and only if:
* without lifetimes, `T_a` is equal to `T_b`
* `T_a` is not a high-ranked function pointer and `T_a` is not a trait object
  and
  * the lifetime of `T_a` outlives the lifetime of `T_b`
* `T_a` is a high-ranked function pointer or `T_a` is a trait object, and
  * `T_b` is given by a substitution of the high-ranked lifetimes in `T_a`

Some examples:
```rust
fn bar<'a>() {
    // `&'static str` is a subtype of `&'a str` because `'static` outlives `'a`
    let s: &'static str = "hi";
    let t: &'a str = s;
}

// `for<'a> fn(&'a i32) -> &'a i32` is a subtype of `fn(&'static i32) -> &'static i32`
// because:
//   * `for<'a> fn(&'a i32) -> &'a i32` is a high-ranked function pointer
//   * `fn(&'static i32) -> &'static i32` is derived from `for<'a> fn(&'a i32) -> &'a i32`
//     via substituting of `'a` with `'static`
let subtype: &(for<'a> fn(&'a i32) -> &'a i32) = &((|x| x) as fn(&_) -> &_);
let supertype: &(fn(&'static i32) -> &'static i32) = subtype;

// `dyn for<'a> Fn(&'a i32) -> &'a i32` is a subtype of `dyn Fn(&'static i32) -> &'static i32`
// because:
//   * `dyn for<'a> Fn(&'a i32) -> &'a i32` is a trait object
//   * `dyn Fn(&'static i32) -> &'static i32` is derived from `dyn for<'a> Fn(&'a i32) -> &'a i32`
//     via substituting of `'a` with `'static`
let subtype: &(dyn for<'a> Fn(&'a i32) -> &'a i32) = &|x| x;
let supertype: &(dyn Fn(&'static i32) -> &'static i32) = subtype;

// `for<'a, 'b> fn(&'a i32, &'b i32)` is a subtype of `for<'c> fn(&'c i32, &'c i32)`
// because:
//   * `for<'a, 'b> fn(&'a i32, &'b i32)` is a high-ranked function pointer
//   * `for<'c> fn(&'c i32, &'c i32)` is derived from `for<'a, 'b> fn(&'a i32, &'b i32)`
//     via substituting of both `'a` and `'b` with `'c`
let subtype: &(for<'a, 'b> fn(&'a i32, &'b i32)) = &((|x, y| {}) as fn(&_, &_));
let supertype: &for<'c> fn(&'c i32, &'c i32) = subtype;
```

Variance:
* property that generic types have with respect to their arguments
* a generic type's *variance* in a parameter is how the subtyping of the
  parameter affects the subtyping of the type:
  * `F<T>` is *covariant* over `T` if `T` being a subtype of `U` implies that
    `F<T>` is a subtype of `F<U>`
  * `F<T>` is *contravariant* over `T` if `T` being a subtype of `U` implies
    that `F<U>` is a subtype of `F<T>`
  * `F<T>` is *invariant* over `T` otherwise
* determining variance of types:
  * let `F<'a>` be `&'a T` and let `'a` be a subtype of `'b` (that is `'a`
    outlives `'b`)
    * then also `&'a T` is a subtype of `&'b T`, meaning that `F<'a>` is
      **covariant** over `'a`
  * let `F<T>` be `&'a T` and let `T` be a subtype of `U`
    * then also `&'a T` is a subtype of `&'a U` since `&'a T` outlives `&'a U`,
      meaning that `F<T>` is **covariant** over `T`
  * let `F<'a>` be `&'a mut T` and let `'a` be a subtype of `'b`
    * then also `&'a mut T` is a subtype of `&'b mut T`, meaning that `F<'a>`
      is **covariant** over `'a`
  * let `F<T>` be `&'a mut T` and let `T` be a subtype of `U`
    * `&'a mut T` is not a subtype of `&'a mut U`
      * `&'a mut T` can be promoted to `&'a mut U` since `T` is a subtype of
        `U`
      * now the value of type `&'a mut T` can be changed to some value of type
        `&'a mut U`
      * that is, `&'a mut T` can refer to a value with shorter lifetime than
        the original `&'a mut T` value
      * hence, there is no guarantee that `&'a mut T` outlives `&'a mut U`
      * hence, `&'a mut T` is not a subtype of `&'a mut U`
    * conversely, `&'a mut U` is not a subtype of `&'a mut T`
    * thus, `F<T>` is **invariant** over `T`
  * let `F<T>` be `*const T` and let `T` be a subtype of `U`
    * then also `*const T` is a subtype of `*const U`, meaning that `F<T>` is
      **covariant** over `T`
  * let `F<T>` be `*mut T` and let `T` be a subtype of `U`
    * `*mut T` can be promoted to `*mut U`
    * then a value of type `*mut U` can be changed due to mutability
    * thus, there is no guarantee that a value of type `*mut T` outlives a
      value of type `*mut U`
    * hence, `*mut T` is not a subtype of `*mut U`, meaning that `F<T>` is
      **invariant** over `T`
  * let `F<T>` be `[T]` and let `T` be a subtype of `U`
    * then also `[T]` is a subtype of `[U]`, meaning that `F<T>` is
      **covariant** over `T`
  * let `F<T>` be `[T; n]` and let `T` be a subtype of `U`
    * then also `[T; n]` is a subtype of `[U; n]`, meaning that `F<T>` is
      **covariant** over `T`
  * let `F<T>` be `fn() -> T` and let `T` be a subtype of `U`
    * then also `fn() -> T` is a subtype of `fn() -> U`, meaning that `F<T>` is
      **covariant** over `T`
  * let `F<T>` be `fn(T) -> ()` and let `T` be a subtype of `U`
    * `f: fn(T) -> ()` cannot be used in a place where `fn(U) -> ()` is used
      since `f` expect an argument that outlives `U`
    * on the other hand, `g: fn(U) -> ()` can be used in a place where
      `fn(T) -> ()` is used since a provided argument of type `T` lives longer
      than an expected argument of type `U`
    * thus, `fn(U) -> ()` is a subtype of `fn(T) -> ()`, meaning that `F<T>` is
      **contravariant** over `T`
  * let `F<T>` be `std::cell::UnsafeCell<T>` and let `T` be a subtype of `U`
    * then `F<T>` is **invariant** over `T` due to interior mutability of
      `std::cell::UnsafeCell<T>`
  * let `F<T>` be `std::marker::PhantomData<T>` and let `T` be a subtype of `U`
    * then also `std::marker::PhantomData<T>` is a subtype of
      `std::marker::PhantomData<U>`, meaning that `F<T>` is **covariant** over
      `T`
  * let `F<'a>` be `dyn Trait<T> + 'a` and let `'a` be a subtype of `'b`
    * then also `dyn Trait<T> + 'a` is a subtype of `dyn Trait<T> + 'b`,
      meaning that `F<'a>` is **covariant** over `'a`
  * let `F<T>` be `dyn Trait<T> + 'a` and let `T` be a subtype of `U`
    * like in the mutability case, `dyn Trait<T> + 'a` cannot be a subtype of
      `dyn Trait<U> + 'a` or vice versa since, due to dynamic manner, there is
      no guarantee that `dyn Trait<T> + 'a` data outlives `dyn Trait<U> + 'a`
      data (or vice versa)
    * thus, `F<T>` is **invariant** over `T`
  * let `F<T>` be `struct`, `enum`, or `union`
    * `F<T>` is **covariant** over `T` if and only if all its fields involving
      `T` are also **covariant** over `T`
    * `F<T>` is **contravariant** over `T` if and only if all its fields
      involving `T` are also **contravariant** over `T`
    * `F<T>` is **invariant** over `T` if and only if any of these cases holds:
      * a `F<T>` field is **invariant** over `T`
      * `T` is used in positions with different variances
  * outside of an `struct`, `enum`, or `union`, the variance for parameters is
    checked at each location separately

Some examples of variance:
```rust
use std::cell::UnsafeCell;
struct Variance<'a, 'b, 'c, 'd, T, U: 'a> {
    x: &'a U,
    y: *const T,
    z: UnsafeCell<&'b f64>,
    v: &'d T,
    w: *mut U,
    f: fn(&'c ()) -> &'c (),
    g: fn(&'d ()) -> (),
}
```
* `struct Variance` is **covariant** in `'a` because
  * `x: &'a U` is **covariant** in `'a`
* `struct Variance` is **invariant** in `'b` because
  * `z: UnsafeCell<&'b f64>` is **invariant** over `&'b f64`
* `struct Variance` is **invariant** in `'c` because
  * `f: fn(&'c ()) -> &'c ()` is **contravariant** over `&'c ()`
  * `f: fn(&'c ()) -> &'c ()` is **covariant** over `&'c ()`
* `struct Variance` is **invariant** in `'d` because
  * `v: &'d T` is **covariant** in `'d`
  * `g: fn(&'d ()) -> ()` is **contravariant** over `&'d ()`
* `struct Variance` is **covariant** in `T` because
  * `y: *const T` is **covariant** in `T`
  * `v: &'d T` is **covariant** in `T`
* `struct Variance` is **invariant** in `U` because
  * `w: *mut U` is **invariant** in `U`

```rust
use std::cell::UnsafeCell;
fn generic_tuple<'short, 'long: 'short>(
    x: (&'long u32, UnsafeCell<&'long u32>),
) {
    let _: (&'short u32, UnsafeCell<&'long u32>) = x;
}
```
* `x`'s type is a tuple and hence the variance for parameters is checked at
  each location inside of the tuple separately
  * `'long` outlives `'short` and hence `&'long u32` is a subtype of
    `&'short u32`, meaning that `&'long u32` is **covariant** in `'long`
  * `UnsafeCell<&'long u32>` is **invariant** in `'long`
  * thus, `(&'long u32, UnsafeCell<&'long u32>)` is a subtype of
    `(&'short u32, UnsafeCell<&'long u32>)`

```rust
fn takes_fn_ptr<'short, 'middle: 'short>(
    f: fn(&'middle ()) -> &'middle (),
) {
    let _: fn(&'static ()) -> &'short () = f;
}
```
* `f`'s type is a function pointer and hence the variance for parameters is
  checked at both argument and return type location separately
  * at the argument type location, `fn(&'middle ()) -> &'middle ()` is
    **contravariant** in `'middle`
  * at the return type location, `fn(&'middle ()) -> &'middle ()` is
    **covariant** in `'middle`
  * thus, `fn(&'middle ()) -> &'middle ()` is a subtype of
    `fn(&'static ()) -> &'short ()`
    * `'static` outlives `'middle`
    * `'middle` outlives `'short`

See [Subtyping and Variance](https://doc.rust-lang.org/reference/subtyping.html),
[Lifetime bounds](https://doc.rust-lang.org/reference/trait-bounds.html#lifetime-bounds),
[Higher-ranked trait bounds](https://doc.rust-lang.org/reference/trait-bounds.html#higher-ranked-trait-bounds),
[Function pointer types](https://doc.rust-lang.org/reference/types/function-pointer.html),
[Trait objects](https://doc.rust-lang.org/reference/types/trait-object.html),
[`std::cell::UnsafeCell`](https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html),
and [`std::marker::PhantomData`](https://doc.rust-lang.org/std/marker/struct.PhantomData.html)
for greater detail.

### Type Coercions

Type coercions are implicit type casts.
* are done automatically at specific locations
* any conversion allowed by coercion can also be performed explicitly via `as`
  (type cast) operator

Coercions can occur at these locations, called *coercion sites*:
* `let` statements
* `static` and `const` item declarations
* arguments for function calls
* instantiations of struct, union, or enum variant fields
* function results

Recursive propagation of coercion sites:
* if the expression on a coercion site is an array literal, where the array has
  type `[U; n]`, then
  * each sub-expression in the array literal is a coercion site for coercion to
    type `U`
* if the expression on a coercion site is an array literal with repeating
  syntax, where the array has type `[U; n]`, then
  * the repeated sub-expression is a coercion site for coercion to type `U`
* if the expression on a coercion site is a tuple that is a coercion site to
  type `(U_0, U_1, ..., U_n)`, then
  * each sub-expression is a coercion site to the respective type, e.g. the 0th
    sub-expression is a coercion site to type `U_0`
* if the expression on a coercion site is a parenthesized sub-expression `(e)`,
  then
  * if `(e)` has type `U`, then `e` is a coercion site to `U`
* if the expression on a coercion site is a block that has type `U`, then
  * the last expression in the block, if it is not semicolon-terminated, is a
    coercion site to `U` (this includes blocks which are part of control flow
    statements, if the block has a known type)

Coercion is allowed between the following types:
* `T` can be coerced to `U` if
  * `T` is a [subtype](https://doc.rust-lang.org/reference/subtyping.html) of
    `U`
* `T` can be coerced to `V` if
  1. `T` can be coerced to `U` and
  1. `U` can be coerced to `V`
* `&mut T` can be coerced to `&T`
* `*mut T` can be coerced to `*const T`
* `&T` can be coerced to `*const T`
* `&mut T` can be coerced to `*mut T`
* `&T` or `&mut T` can be coerced to `&U` if
  * `T` implements `Deref<Target = U>`
* `&mut T` can be coerced to `&mut U` if
  * `T` implements `DerefMut<Target = U>`
* `type_constructor(T)` can be coerced to `type_constructor(U)` if
  1. `type_constructor(T)` is one of
     * `&T`
     * `&mut T`
     * `*const T`
     * `*mut T`
     * `Box<T>`
  1. `U` can be obtained from `T` by
     [unsized coercion](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions)
* function item types can be coerced to `fn` pointers
* non capturing closures can be coerced to `fn` pointers
* `!` can be coerced to any `T`

Unsized coercions:
* conversions of sized types to unsized ones
* if `T` can be coerced to `U` by unsized coercion, then
  * an implementation of `Unsize<U>` for `T` will be provided
* `[T; n]` can be coerced to `[T]`
* `T` can be coerced to `dyn U` if
  1. `T` implements `U + Sized`
  1. `U` is
     [object safe](https://doc.rust-lang.org/reference/items/traits.html#object-safety)
* `Foo<..., T, ...>` can be coerced to `Foo<..., U, ...>` if
  1. `Foo` is a struct
  1. `T` implements `Unsize<U>`
  1. the last field of `Foo` has a type involving `T`
     * if this field has type `Bar<T>`, then
       * `Bar<T>` implements `Unsize<Bar<U>>`
  1. `T` is not part of the type of any other fields
* a type `Foo<T>` can implement `CoerceUnsized<Foo<U>>` if
  * `T` implements `Unsize<U>` or `CoerceUnsized<Foo<U>>`
    * this allows `Foo<T>` to be coerced to `Foo<U>`

Least upper bound coercions:
* only used in the following situations:
  * to find the common type for a series of `if` branches
  * to find the common type for a series of `match` arms
  * to find the common type for array elements
  * to find the type for the return type of a closure with multiple return
    statements
  * to check the type for the return type of a function with multiple return
    statements
* algorithm:
  * input: types `T_0`, `T_1`, ..., `T_n`
  * output: type `T_t`
  * method:
    * set `T_t` to `T_0`
    * for `i` in `1..n`:
      * if `T_i` can be coerced to `T_t`
        * no change is made
      * otherwise, if `T_t` can be coerced to `T_i`
        * set `T_t` to `T_i`
      * otherwise
        * set `T_t` to mutual supertype of `T_t` and `T_i`

See [Type coercions](https://doc.rust-lang.org/reference/type-coercions.html),
[Type cast expressions](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions),
[Subtyping and Variance](https://doc.rust-lang.org/reference/subtyping.html),
[Object Safety](https://doc.rust-lang.org/reference/items/traits.html#object-safety),
[RFC 255](https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md),
[RFC 546](https://github.com/rust-lang/rfcs/blob/master/text/0546-Self-not-sized-by-default.md),
[`std::marker::Unsize`](https://doc.rust-lang.org/std/marker/trait.Unsize.html),
[`std::ops::CoerceUnsized`](https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html),
and [`std::marker::Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html)
for greater detail.

## Declarations

Grammar:
```
declaration:
    let_statement
    declaration_item

declaration_item:
    use_declaration
    constant_item
    static_item
    type_alias
    struct
    union
    enumeration
    function
    extern_block
```

### Use Declarations

Grammar:
```
use_declaration:
    "use" use_tree ";"

use_tree:
    (simple_path? "::")? ("*" | "{" (use_tree ("," use_tree)* ","?)? "}")
    simple_path ("as" (identifier | "_"))?
```
* a `use` declaration creates one or more local name bindings synonymous with
  some other path
* `use` declarations may appear in modules or blocks
* `use` declarations are resolved after macro expansion, e.g. this will not
  produce an error:
  ```rust
  macro_rules! m {
      ($x: item) => { $x $x }
  }

  m!(use std as _;);
  ```

Forms of a `use` declaration:
* `use a::b::c;` makes `c` to be an alias for `a::b::c` in the current scope
* `use a::b::c as foo;` makes `foo` to be an alias for `a::b::c` in the current
  scope
* `use a::b::*;` brings all public items defined under the `a::b` in the
  current scope
* `use a::{self, b::c, d, e::*, f::g as h};` is the equivalent of
  ```rust
  // `self` refers to the common parent module, hence `use a;`
  use a;
  use a::b::c;
  use a::d;
  use a::e::*;
  use a::f::g as h;
  ```
* nesting is also supported, e.g. `use a::b::{self as c, d::{self, *}};` is the
  equivalent of
  ```rust
  use a::b as c;
  use a::b::d;
  use a::b::d::*;
  ```
* `use path as _;` imports `path` without binding it to a name
  * `use path::to::trait as _;` imports trait's methods but not the `trait`
    symbol itself (recall that that to use trait's method it must be first
    imported)
* `use path::* as _;` imports all the items under the `path` in their
  unnameable form

See [Use declarations](https://doc.rust-lang.org/reference/items/use-declarations.html),
[Paths](https://doc.rust-lang.org/reference/paths.html),
[Modules](https://doc.rust-lang.org/reference/items/modules.html), and
[Block expressions](https://doc.rust-lang.org/reference/expressions/block-expr.html)
for greater detail.

### Variables

Grammar:
```
let_statement:
    outer_attribute* "let" pattern_no_top_alt (":" type)?
        ("=" expression ("else" block_expression)?)? ";"
```
* introduces a new set of variables given by a `pattern_no_top_alt`
* `pattern_no_top_alt` can be annotated with `type`
* variables in `pattern_no_top_alt` can be initialized by `expression`
* if `else` is not present, `pattern_no_top_alt` must be irrefutable
* if `else` is present
  * `pattern_no_top_alt` can be refutable
  * `expression` must not be a `lazy_boolean_expression` or end with a `}`
  * `block_expression` must evaluate to never type
* the semantics of `else` part is that if `pattern_no_top_alt` fails to match
  then the `block_expression` is executed

Variables:
* are allocated on stack frame, i.e. a variable can be
  * a named local variable
  * a named function parameter
  * an anonymous temporary (e.g. created during an expression evaluation)
* are defined as immutable by default
  * to define a mutable variable, use the `mut` keyword

  ```rust
  let x = 5;      // immutable variable
  let mut y = 7;  // mutable variable
  ```
* are scoped
* are not initialized
  * all variables must be initialized before their first use
* can be shadowed:
  ```rust
  let x = "foo";    // x is immutable and str
  let x = x.len();  // x is shadowed - still immutable but integer
  ```

See [Identifiers](https://doc.rust-lang.org/reference/identifiers.html),
[`let` statements](https://doc.rust-lang.org/reference/statements.html#let-statements),
[Variables](https://doc.rust-lang.org/reference/variables.html) and
[Temporaries](https://doc.rust-lang.org/reference/expressions.html#temporaries)
for greater detail.

### Constants

Grammar:
```
constant_item:
    "const" (identifier | "_") ":" type ("=" expression)? ";"
```

Constants are scoped and always immutable.

Example:
```rust
const THREE: u32 = 1 + 2;
```
* convention: use upper case and underscores for constant names

See [Constant items](https://doc.rust-lang.org/reference/items/constant-items.html)
and [Constant evaluation](https://doc.rust-lang.org/reference/const_eval.html)
for greater detail.

### Statics

Grammar:
```
static_item:
    "static" "mut"? identifier ":" type ("=" expression)? ";"
```

See [Static items](https://doc.rust-lang.org/reference/items/static-items.html)
for greater detail.

### Type Aliases

Grammar:
```
type_alias:
    "type" identifier generic_params? (":" type_param_bounds)? where_clause?
        ("=" type where_clause?)? ";"
```

See [Type aliases](https://doc.rust-lang.org/reference/items/type-aliases.html)
for greater detail.

### Structs

Grammar:
```
struct:
    "struct" identifier generic_params? where_clause?
        ("{" struct_fields? "}" | ";")
    "struct" identifier generic_params? "(" tuple_fields? ")" where_clause? ";"

struct_fields:
    struct_field ("," struct_field)* ","?
struct_field:
    outer_attribute* visibility? identifier ":" type

tuple_fields:
    tuple_field ("," tuple_field)* ","?
tuple_field:
    outer_attribute* visibility? type
```

#### Structs with Named Fields

Declaration:
```rust
struct Point3D {
    x: f64,
    y: f64,
    z: f64,
}
```
* declare a new type `Point3D` as a struct containing three `f64` items named
  `x`, `y` and `z`, respectively

Making an instance:
```rust
let p1 = Point3D {x: 0.5, y: -1.2, z: 1.0};      // (1)
let mut p2 = Point3D {z: 1.0, y: -1.2, x: 0.5};  // (2)
```
* at `(1)` an instance of `Point3D` is created and assigned to `p1`
* at `(2)` happens the same but this time the instance is assigned to `p2`
* the order of initializers does not matter in Rust, thus `p1` and `p2` are
  equal

Accessing an element:
```rust
p2.x += p1.x;
```
* an element of a struct is accessed by its name using dot operator (`.`)

Field init shorthand:
```rust
fn x_axis_point(x: f64) -> Point3D {
    Point {y: 0.0, z: 0.0, x}
}
```
* if the name of a variable coincides with the name of a field then initializer
  `name: name` can be shortened to just `name`

Struct update syntax:
```rust
let origin = Point3D {x: 0.0, y: 0.0, z: 0.0};
let z1 = Point3D {z: 1.0, ..origin};
```
* missing initializers are taken from `origin`, so the `z1` is equal to
  `Point3D {x: 0.0, y: 0.0, z: 1.0}`
* note that in case `Point3D` contains a field that can be only moved (e.g. a
  field of `String` type), then `origin` cannot be used after the assignment to
  `z1` is finished
* `z1` must be of the same type as `origin`

#### Tuple-like Structs

Declaration:
```rust
struct Color(u8, u8, u8);
```
* declare a new type `Color` as a struct containing three `u8` elements

Making an instance:
```rust
let red = Color(255, 0, 0);
let ctor = Color;
let blue = ctor(0, 0, 255);
```
* create an instance of `Color` and assign it to `red`
* `Color` behaves like function/constructor

Accessing an element:
```rust
let green = red.1;
```
* elements are accessed like in tuples

Struct update:
```rust
let black = Color(0, 0, 0);
let red = Color {0: 255, ..black};
```
* decimal integer literal as a field name specifies which field is updated
* `..origin` sets the rest of fields from `origin` using the copy/borrow
  strategy

#### Unit-like Structs

Declaration:
```rust
struct Ground;
struct Sink;
```
* declare two new distinct types, `Ground` and `Sink`, with no elements
* unit-like structs become useful when used together with traits

Making an instance:
```rust
let ground = Ground;
let ground2 = Ground {};
```
* create an instance of `Ground` and assign it to `ground`
* `Ground` can be optionally followed by `{}` to explicitly denote there are no
  fields

See [Structs](https://doc.rust-lang.org/reference/items/structs.html) and
[Struct expressions](https://doc.rust-lang.org/reference/expressions/struct-expr.html)
for greater detail.

### Unions

Grammar:
```
union:
    "union" identifier generic_params? where_clause? "{" struct_fields "}"
```

See [Unions](https://doc.rust-lang.org/reference/items/unions.html) for greater
detail.

### Enumerations

Grammar:
```
enumeration:
    "enum" identifier generic_params? where_clause? "{" enum_items? "}"

enum_items:
    enum_item ("," enum_item)* ","?
enum_item:
    outer_attribute* visibility?
        identifier (enum_item_tuple | enum_item_struct)?
        enum_item_discriminant?

enum_item_tuple:
    "(" tuple_fields? ")"
enum_item_struct:
    "{" struct_fields? "}"
enum_item_discriminant:
    "=" expression
```

Enumerations represent a sum of enumeration types distinguished by
constructors.

Definition and use of enumerations:
```rust
enum Animal {
    // Enum variant:
    Dog(String, f64),
    // Struct-like enum variant:
    Cat { name: String, weight: f64 },
    // Unit variant:
    Mouse,
}

let mut a: Animal = Animal::Dog("Sunny".to_string(), 13.5);
a = Animal::Cat { name: "Ginger".to_string(), weight: 4.7 };
a = Animal::Mouse;

// Values are extracted using pattern matching:
if let Animal::Cat { name, _ } == a {
    println!("Cat's name is {name}");
}
```

Like structs, also enumerations support defining methods on them:
```rust
enum FileError {
    NotFound,
    Read,
    Write,
}

impl FileError {
    fn detail(&self) -> String {
        match self {
            FileError::NotFound => String::from("File not found"),
            FileError::Read => String::from("Error while reading"),
            FileError::Write => String::from("Error while writing"),
        }
    }
}
```

Syntactically, enumerations allow to use a visibility annotation for their
variants but this is rejected during the validation:
```rust
// Syntactical macros can use the enum definition to generate a code and throw
// out the old enum definition so it will not be analyzed by semantic analysis
// (if so, it will be rejected)
#[some_macro("foo")]
enum Enum {
    pub A,
    pub(crate) B(),
}
```

A *field-less enum* is an enum where no constructors contain field:
```rust
enum FieldLessEnum {
    CtorA(),
    CtorB{},
    CtorC,
}
```

A *unit-only enum* only contains unit variants:
```rust
enum UnitOnly {
    UnitA,
    UnitB,
    UnitC,
}
```

A *zero-variant enum* is an enum with no variants and thus it cannot be
instantiated:
```rust
enum ZeroVariants {}
```
* zero-variant enums are equivalent to never type:
  ```rust
  let x: ZeroVariants = panic!();
  ```
* coercion into other types is not allowed:
  ```rust
  let y: u32 = x;  // type mismatch
  ```

#### Discriminants

A discriminant is a number associated with a constructor used to distinguish
between variants of one enum instance.
* its type is `isize` under the [default representation](https://doc.rust-lang.org/reference/type-layout.html#the-default-representation)
* however, compiler is allowed to use a smaller type in its actual memory
  layout

##### Discriminant Values

A discriminant value can be set in two ways:
1. **Implicitly**, if the value of the discriminant is not specified
   explicitly:
   * the value of the discriminant is the value of the discriminant of the
     previous variant plus one
   * if the value of the discriminant of the first variant is not specified
     explicitly it is set to zero

   Example:
   ```rust
   // Unit only enumeration => setting discriminants explicitly is allowed
   enum Example {
       VarA,        // Implicitly set to 0
       VarB = 123,  // Explicitly set to 123
       VarC,        // Implicitly set to 124
   }
   ```
1. **Explicitly**, using `=` followed by a [constant expression](https://doc.rust-lang.org/reference/const_eval.html#constant-expressions),
   under these circumstances:
   * the enumeration is unit-only
   * a [primitive representation](https://doc.rust-lang.org/reference/type-layout.html#primitive-representations) is used

   Examples:
   ```rust
   #[repr(u8)]      // A primitive (u8) representation (discriminant values ranges from 0 to 255)
   enum Enum {
       Unit = 3,    // Unit = 3 (set explicitly)
       Tuple(u16),  // Tuple = 4 (set implicitly)
       Struct {     // Struct = 1 (set explicitly)
           a: u8,
           b: u16,
       } = 1,
   }

   enum Bad1 {
       A = 1,
       B = 1,   // ERROR: 1 is already used
   }

   enum Bad2 {
       A,      // Implicitly set to 0
       B,      // Implicitly set to 1
       C = 1,  // ERROR: 1 is already used
   }

   #[repr(u8)]
   enum Bad3 {
       A = 255,  // Explicitly set to 255
       B,        // ERROR: Implicitly set to 256 which cannot fit to u8 (overflow)
   }
   ```

##### How to Get the Discriminant Value

* using [`std::mem::discriminant`](https://doc.rust-lang.org/std/mem/fn.discriminant.html)
  (can be used only for `==` and `!=` comparison)
  ```rust
  enum Enum {
    VarA(&'static str),
    VarB(i32),
    VarC(i32),
  }

  assert_eq!(mem::discriminant(&Enum::VarA("abc")), mem::discriminant(&Enum::VarA("def")));
  assert_ne!(mem::discriminant(&Enum::VarC(2)), mem::discriminant(&Enum::VarC(3)));
  ```
* via typecasting (can be used only for enums having only unit variants or for
  field-less enums where only unit variants are explicit)
  ```rust
  enum Enum {
      A,  // 0
      B,  // 1
      C,  // 2
  }

  assert_eq!(Enum::B as isize, 1);

  #[repr(u8)]
  enum FieldLess {
      Tuple(),            // 0
      Struct{},           // 1
      Unit,               // 2
      ExplicitUnit = 42,  // 42
  }

  assert_eq!(FieldLess::Tuple() as u8, 0);
  assert_eq!(FieldLess::Struct{} as u8, 1);
  assert_eq!(FieldLess::ExplicitUnit as u8, 42);

  #[repr(u8)]
  enum FieldLess2 {
      Tuple() = 2,
      Unit,
  }

  // ERROR: Typecast cannot be used as non-unit variant's discriminant has been
  //        set explicitly
  // assert_eq!(FieldLess2::Unit as u8, 3);
  ```
* via (unsafe) pointer casting (can be used only for enums using a primitive
  representation)
  ```rust
  #[repr(u8)]
  enum Foo {
      A,                         // 0
      B { a: i16, b: i16 } = 3,  // 3
      C(i32) = 5,                // 5
  }

  impl Foo {
      fn discriminant(&self) -> u8 {
          unsafe { *(self as *const Self as *const u8) }
      }
  }

  let a = Foo::A;
  let b = Foo::B{a: -1, b: 4};
  let c = Foo::C(3);

  assert_eq!(a.discriminant(), 0);
  assert_eq!(b.discriminant(), 3);
  assert_eq!(c.discriminant(), 5);
  ```

See [Enumerations](https://doc.rust-lang.org/reference/items/enumerations.html),
[Enumerated types](https://doc.rust-lang.org/reference/types/enum.html),
[Struct expressions](https://doc.rust-lang.org/reference/expressions/struct-expr.html),
[The `Rust` Representation](https://doc.rust-lang.org/reference/type-layout.html#the-default-representation),
and [Primitive representations](https://doc.rust-lang.org/reference/type-layout.html#primitive-representations)
for greater detail.

### Functions

Grammar:
```
function:
    function_qualifiers "fn" identifier generic_params?
        "(" function_parameters? ")"
        function_return_type? where_clause?
        (block_expression | ";")

function_qualifiers:
    "const"? "async"? "unsafe"? ("extern" abi?)?
abi:
    string_literal
    raw_string_literal

function_parameters:
    self_param ","?
    (self_param ",")? function_param ("," function_param)* ","?
self_param:
    outer_attribute* (shorthand_self | typed_self)
shorthand_self:
    ("&" lifetime?)? "mut"? "self"
typed_self:
    "mut"? "self" ":" type
function_param:
    outer_attribute* (function_param_pattern | "..." | type)
function_param_pattern:
    pattern_no_top_alt ":" (type | "...")

function_return_type:
    "->" type
```

Simple function definition and simple call example:
```rust
fn main() {
    simple_fun();
}

fn simple_fun() {
    println!("Hello!");
}
```

Function with parameters:
```rust
fn fun_with_params(x: i32, y: i32) {
    println!("x: {x}, y: {y}");
}

fn main() {
    fun_with_params(5, 3);
}
```

Function returning value:
```rust
fn max(a: i32, b: i32) -> i32 {
    if (a > b) {
        return a;
    }
    b
}

fn main() {
    let x = max(1, 2);

    println!("max(1, 2): {x}");
}
```

See [Functions](https://doc.rust-lang.org/reference/items/functions.html) for
greater detail.

### External Blocks

Grammar:
```
extern_block:
    "unsafe"? "extern" abi? "{" inner_attribute* external_item* "}"

external_item:
    outer_attribute* (
        macro_invocation_semi |
        (visibility? (static_item | function))
    )
```

See [External blocks](https://doc.rust-lang.org/reference/items/external-blocks.html)
for greater detail.

## Ownership

* ownership is a strategy of keeping of a track of used memory
  * whether the memory is used or not is decided on compile time
* ownership rules
  1. every value in Rust has an owner
  1. there can be only one owner at a time
  1. when the owner goes out of scope, the value will be dropped (Rust calls
     [`drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop)
     on it)
* see [Pointer types](https://doc.rust-lang.org/reference/types/pointer.html)
  and [Slice types](https://doc.rust-lang.org/reference/types/slice.html) for
  greater detail

### Moves, Clones, and Copies

When a value is moved from one variable to another, the value of the former
variable is considered invalid and that variable cannot be used:
```rust
let a = String::from("Hey!");
let b = a;  // `a` cannot be used from now since its value is invalid
```

This can be bypassed using the `clone` method:
```rust
let a = String::from("Hello!");
let b = a.clone();  // both `a` and `b` stay valid
```

However, if a type implements the `Copy` trait, a value is not moved but copied
and it stays valid:
```rust
let x = 5;
ley y = x;  // `x` is valid since `i32` implements the `Copy` trait
```

> [!NOTE]
> If a type or any of its part implements the `Drop` trait it cannot be
> annotated with (it cannot implement) the `Copy` trait.

Types that can implement the `Copy` trait are in general:
* any group of simple scalar values
* nothing that requires allocation or is some form of resource

This includes:
* all integer types
* `bool` type
* all floating-point types
* `char` type
* tuples containing only types implementing `Copy`

Moving and copying concepts hold also for functions and other assignment-like
operations:
* `function(x)` moves/copies `x` to its parameter
* `return x` moves/copies `x` outside of function as its return value

### References and Borrowing

* a reference is holding an address to some kind of data/value
* a reference lifetime starts with its definition and ends after its last use
  in the current scope
* a reference is guaranteed to point to a valid data/value during the reference
  lifetime
* a reference points to a value but it not owns it
  * a referenced value cannot be changed and thus there can be many references
    for the same memory location at the same time
* a reference is created using `&` unary operator
  * e.g., `&a` is a reference to the value owned by `a`
* `&` can be also used to declare a reference type
  * e.g., `&i32` is a reference type of `i32` type
* creating a reference is called *borrowing*
* using `mut` together with `&` creates/declares a *mutable* reference
  * `&mut a` is a mutable reference to the value of `a`
  * `&mut i32` is a mutable reference type of `i32` type
* a mutable reference allows to change the value it is referring to
  * no other references to that value are allowed to exist during the mutable
    reference lifetime

### Dangling Pointers

Rust will not allow dangling pointers:
```rust
fn dangle() {
    let s = String::from("Hey!");

    &s  // `s` goes out of scope so it is dropped; `&s` points to freed memory
}
```

### Slices

* a slice is a reference to contiguous sequence of elements in a collection
* a slice is made using index (`&x[r]`) expression, where `&x` is a reference
  to some collection type and `r` has a range type; the value of `&x[r]` is the
  reference to the portion of `x`; some examples:
  ```rust
  let s = String::from("abcdefgh");

  let x = &s[1..4];  // `x` points to `s[1]` ("bcd") and has type `&String`
  let y = &s[..3];   // same as `&s[0..3]`
  let z = &s[2..];   // same as `&s[2..(s.len())]`
  let w = &s[..];    // same as `&s[0..(s.len())]`

  // let t = &s[-1..0];  // error: `a` is not of a type `usize`
  // let t = &s[1..0];   // panic: `a` is not less or equal to `b`
  let t = &s[1..=0];     // ok: `t == ""`, `a <= b` (`1 <= 1`)
  // let t = &s[2..=0];  // panic: `a` is not less or equal to `b` (`2 > 1`)

  let a = [1, 2, 3, 4, 5];

  let x = &a[1..3];  // `assert_eq!(x, &[2, 3]);`, `x` has type `&[i32]`
  ```
> [!NOTE]
> 1. A range `a..b` used to make a slice must have `a <= b`, where both `a` and
>    `b` are of the `usize` type.
> 1. String (`str`) slice range indices must occur at valid UTF-8 character
>    boundaries. Otherwise the program panics.
> 1. String literals have a type `&str` since they are slices of a binary data
>    stored in the data section of a program.
> 1. `String` implements the `Deref` trait that converts `&String` to `&str` by
>    calling a `deref` method (the code is generated by Rust during compile
>    time). As a consequence, if a function `fun` has a signature
>    `fn fun(s: &str)` and `x` has a type `&String` we can `fun(x)` without any
>    worries.

## Expressions

Grammar:
```
expression:
    expression_without_block
    expression_with_block

expression_without_block:
    outer_attribute* (
        break_expression |
        continue_expression |
        return_expression |
        closure_expression |
        operator_expression |
        range_expression |
        index_expression |
        call_expression |
        field_expression |
        tuple_indexing_expression |
        method_call_expression |
        await_expression |
        path_expression |
        async_block_expression |
        atomic_expression |
        grouped_expression |
        macro_invocation
    )
expression_with_block:
    outer_attribute* (
        loop_expression |
        if_expression |
        if_let_expression |
        match_expression |
        block_expression |
        unsafe_block_expression
    )

operator_expression:
    assignment_expression
    compound_assignment_expression
    lazy_boolean_expression
    comparison_expression
    arithmetic_or_logical_expression
    type_cast_expression
    negation_expression
    dereference_expression
    borrow_expression
    error_propagation_expression
```

References:
* [Expressions reference](https://doc.rust-lang.org/reference/expressions.html)
* [Operators and symbols list](https://doc.rust-lang.org/book/appendix-02-operators.html) (see also [here](https://doc.rust-lang.org/reference/tokens.html#punctuation))
* [Operator precedence](https://doc.rust-lang.org/reference/expressions.html#expression-precedence)

### Loop Expressions

Grammar:
```
loop_expression:
    loop_label? (
        "loop" block_expression
        "while" (expression - struct_expression) block_expression
        "while" "let" pattern "=" (scrutinee - lazy_boolean_expression)
            block_expression
        "for" pattern "in" (expression - struct_expression) block_expression
        block_expression
    )
loop_label:
    lifetime_or_label ":"

break_expression:
    "break" lifetime_or_label? expression?
continue_expression:
    "continue" lifetime_or_label?
```

`loop { body }`:
* execute `body` infinitely
* if `body` does not contain `break`, the type of the expression is `!`;
  otherwise, the type of the expression is the type of the `break` expression
* the type of the expression must be compatible with the type of every `break`
  expression inside `body`
* the value of the expression is the value returned by a `break` expression
  from `body`

`while condition { body }`:
* if `condition` is true execute `body` and go to the next iteration
* `condition` must not be `struct_expression`
* the type and the value of the expression, `body` and the `break` expression
  follow the same rules as in the `loop` case

`while let pattern = scrutinee { body }`:
* if the value of `scrutinee` matches `pattern` execute `body` and go to the
  next iteration
* `scrutinee` must not be `lazy_boolean_expression`
* the type and the value of the expression, `body` and the `break` expression
  follow the same rules as in the `loop` case

`for pattern in expression { body }`:
* `expression` must not be `struct_expression`
* the value of `expression` must implement
  [`std::iter::IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)
* `pattern` must be irrefutable
* if the iterator yield a value, the value is matched against `pattern` and the
  `body` is executed after which the control returns to the next iteration
* a `'label: for pattern in expression { body }` is equivalent to
  ```rust
  {
      let result = match IntoIterator::into_iter(expression) {
          // Don't drop temporaries from `expression` before loop is finished
          mut iter => 'label: loop {
              let mut next;
              match Iterator::next(&mut iter) {
                  Option::Some(val) => next = val,
                  Option::None => break,
              };
              let pattern = next;
              let () = { body };
          },
      };
      result
  }
  ```

Loop labels:
* a loop expression can be optionally labeled
* labels can be shadowed
  ```rust
  'a: loop {         // (1)
      'a: loop {     // (2)
          break 'a;  // exit (2) loop
      }
      break 'a;      // exit (1) loop
  }
  ```

`break` expressions:
* allowed only inside of the body of a loop or a labeled block expression
* `break` immediately exits from the innermost loop or a labeled block
  expression
  * if a label is specified, `break` immediately exits from a loop labeled with
    this label
  * in a labeled block expression the label part is mandatory
* if the expression part is present, `break` returns the value of the
  expression to the associated loop or labeled block expression
  * just `break` returns `()`

`continue` expressions:
* allowed only inside of the body of a loop
* associated with the innermost loop expression
  * if the label part is present, the `continue` expression is associated with
    the loop expression labeled with this label
* `continue` immediately stops the current iteration and returns the control
  back to the associated loop so the next iteration can be started

See [Loops and other breakable expressions](https://doc.rust-lang.org/reference/expressions/loop-expr.html#loops-and-other-breakable-expressions)
for greater detail.

### `if` Expressions

Grammar:
```
if_expression:
    "if" (expression - struct_expression) block_expression
        ("else" (block_expression | if_expression | if_let_expression))?

if_let_expression:
    "if" "let" pattern "=" (scrutinee - lazy_boolean_expression) block_expression
        ("else" (block_expression | if_expression | if_let_expression))?
```
* the conditional `expression` must not be `struct_expression` and must be of
  a type `bool`
* the `scrutinee` must not be `lazy_boolean_expression`
* all block expressions must have the same type
* the value of the `if` expression is the value of its *then* branch if the
  conditional expression evaluates to `true`; otherwise, the value of the `if`
  expression is the value of its *else* branch
* if neither *then* nor *else* branch are evaluated the value of the `if`
  expression is `()`
* in an `if let` expression, if the value of `scrutinee` matches `pattern` the
  whole expression has the value of its *then* branch; otherwise, it has the
  value of its *else* branch or `()` if the *else* branch is missing
  * `if let` expression
    ```rust
    if let PATTERN = EXPRESSION {
        then_branch
    } else {
        else_branch
    }
    ```
    is equivalent to
    ```rust
    match EXPRESSION {
        PATTERN => { then_branch },
        _ => { else_branch },
    }
    ```

Example:
```rust
fn decide(x: u8, y: &Option<u8>, z: u8) -> u8 {
    if x > 127 {
        x
    } else if let Some(x) = *y {
        x
    } else {
        z
    }
}

fn main() {
    let a = Some(8);
    let b = None;

    println!("{}", decide(200, &a, 42));  // prints "200"
    println!("{}", decide(20, &a, 42));   // prints "8"
    println!("{}", decide(20, &b, 42));   // prints "42"
}
```

See [`if` and `if let` expressions](https://doc.rust-lang.org/reference/expressions/if-expr.html)
for greater detail.

### `return` Expressions

Grammar:
```
return_expression:
    "return" expression?
```

See [`return` expressions](https://doc.rust-lang.org/reference/expressions/return-expr.html)
for greater detail.

### Closure Expressions

Grammar:
```
closure_expression:
    "move"? ("||" | "|" closure_parameters? "|") (
        expression | "->" type_no_bounds block_expression
    )

closure_parameters:
    closure_param ("," closure_param)* ","?

closure_param:
    outer_attribute* pattern_no_top_alt (":" type)?
```

#### Hints

* [How do I store a closure in a struct in Rust?](https://stackoverflow.com/questions/27831944/how-do-i-store-a-closure-in-a-struct-in-rust)

See [Closure expressions](https://doc.rust-lang.org/reference/expressions/closure-expr.html)
for greater detail.

### Assignment Expressions

Grammar:
```
assignment_expression:
    expression "=" expression

compound_assignment_expression:
    expression "+=" expression
    expression "-=" expression
    expression "*=" expression
    expression "/=" expression
    expression "%=" expression
    expression "&=" expression
    expression "|=" expression
    expression "^=" expression
    expression "<<=" expression
    expression ">>=" expression
```

#### Operators Overloading

* `a += b` is a syntactical sugar for `AddAssign::add_assign(&mut a, b)` (see
  [`std::ops::AddAssign`](https://doc.rust-lang.org/std/ops/trait.AddAssign.html)
  trait)
  ```rust
  pub trait AddAssign<Rhs = Self> {
      // Required method
      fn add_assign(&mut self, rhs: Rhs);
  }
  ```
* `a -= b` is a syntactical sugar for `SubAssign::sub_assign(&mut a, b)` (see
  [`std::ops::SubAssign`](https://doc.rust-lang.org/std/ops/trait.SubAssign.html)
  trait)
  ```rust
  pub trait SubAssign<Rhs = Self> {
      // Required method
      fn sub_assign(&mut self, rhs: Rhs);
  }
  ```
* `a *= b` is a syntactical sugar for `MulAssign::mul_assign(&mut a, b)` (see
  [`std::ops::MulAssign`](https://doc.rust-lang.org/std/ops/trait.MulAssign.html)
  trait)
  ```rust
  pub trait MulAssign<Rhs = Self> {
      // Required method
      fn mul_assign(&mut self, rhs: Rhs);
  }
  ```
* `a /= b` is a syntactical sugar for `DivAssign::div_assign(&mut a, b)` (see
  [`std::ops::DivAssign`](https://doc.rust-lang.org/std/ops/trait.DivAssign.html)
  trait)
  ```rust
  pub trait DivAssign<Rhs = Self> {
      // Required method
      fn div_assign(&mut self, rhs: Rhs);
  }
  ```
* `a %= b` is a syntactical sugar for `RemAssign::rem_assign(&mut a, b)` (see
  [`std::ops::RemAssign`](https://doc.rust-lang.org/std/ops/trait.RemAssign.html)
  trait)
  ```rust
  pub trait RemAssign<Rhs = Self> {
      // Required method
      fn rem_assign(&mut self, rhs: Rhs);
  }
  ```
* `a &= b` is a syntactical sugar for `BitAndAssign::bitand_assign(&mut a, b)`
  (see [`std::ops::BitAndAssign`](https://doc.rust-lang.org/std/ops/trait.BitAndAssign.html)
  trait)
  ```rust
  pub trait BitAndAssign<Rhs = Self> {
      // Required method
      fn bitand_assign(&mut self, rhs: Rhs);
  }
  ```
* `a |= b` is a syntactical sugar for `BitOrAssign::bitor_assign(&mut a, b)`
  (see [`std::ops::BitOrAssign`](https://doc.rust-lang.org/std/ops/trait.BitOrAssign.html)
  trait)
  ```rust
  pub trait BitOrAssign<Rhs = Self> {
      // Required method
      fn bitor_assign(&mut self, rhs: Rhs);
  }
  ```
* `a ^= b` is a syntactical sugar for `BitXorAssign::bitxor_assign(&mut a, b)`
  (see [`std::ops::BitXorAssign`](https://doc.rust-lang.org/std/ops/trait.BitXorAssign.html)
  trait)
  ```rust
  pub trait BitXorAssign<Rhs = Self> {
      // Required method
      fn bitxor_assign(&mut self, rhs: Rhs);
  }
  ```
* `a <<= b` is a syntactical sugar for `ShlAssign::shl_assign(&mut a, b)` (see
  [`std::ops::ShlAssign`](https://doc.rust-lang.org/std/ops/trait.ShlAssign.html)
  trait)
  ```rust
  pub trait ShlAssign<Rhs = Self> {
      // Required method
      fn shl_assign(&mut self, rhs: Rhs);
  }
  ```
* `a >>= b` is a syntactical sugar for `ShrAssign::shr_assign(&mut a, b)` (see
  [`std::ops::ShrAssign`](https://doc.rust-lang.org/std/ops/trait.ShrAssign.html)
  trait)
  ```rust
  pub trait ShrAssign<Rhs = Self> {
      // Required method
      fn shr_assign(&mut self, rhs: Rhs);
  }
  ```

See [Assignment expressions](https://doc.rust-lang.org/reference/expressions/operator-expr.html#assignment-expressions)
and [Compound assignment expressions](https://doc.rust-lang.org/reference/expressions/operator-expr.html#compound-assignment-expressions)
for greater detail.

### Range Expressions

Grammar:
```
range_expression:
    expression ".." expression
    expression ".."
    ".." expression
    ".."
    expression "..=" expression
    "..=" expression
```
* `a..b` constructs [`std::ops::Range`](https://doc.rust-lang.org/std/ops/struct.Range.html)
  object; `(a..b).contains(&x)` is equivalent to `a <= x && x < b`
* `a..` constructs [`std::ops::RangeFrom`](https://doc.rust-lang.org/std/ops/struct.RangeFrom.html)
  object; `(a..).contains(&x)` is equivalent to `a <= x`
* `..b` constructs [`std::ops::RangeTo`](https://doc.rust-lang.org/std/ops/struct.RangeTo.html)
  object; `(..b).contains(&x)` is equivalent to `x < b`
* `..` constructs [`std::ops::RangeFull`](https://doc.rust-lang.org/std/ops/struct.RangeFull.html)
  object; this range has no boundaries
* `a..=b` constructs [`std::ops::RangeInclusive`](https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html)
  object; `(a..=b).contains(&x)` is equivalent to `a <= x && x <= b`
* `..=b` constructs [`std::ops::RangeToInclusive`](https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html)
  object; `(..=b).contains(&x)` is equivalent to `x <= b`

See [Range expressions](https://doc.rust-lang.org/reference/expressions/range-expr.html)
for greater detail.

### Lazy Boolean Expressions

Grammar:
```
lazy_boolean_expression:
    expression "||" expression
    expression "&&" expression
```

The meaning and associativity of each operator (operators lower in the table
have higher precedence):
| **Operator** | **Meaning** | **Associativity** |
| ------------ | ----------- | ----------------- |
| `\|\|` | logical or | left-to-right |
| `&&` | logical and | left-to-right |

`||` and `&&` differs from `|` and `&` in a way that the right-hand side
expression is evaluated when its value is needed.

See [Lazy boolean operators](https://doc.rust-lang.org/reference/expressions/operator-expr.html#lazy-boolean-operators)
for greater detail.

### Comparison Expressions

Grammar:
```
comparison_expression:
    expression "==" expression
    expression "!=" expression
    expression ">" expression
    expression "<" expression
    expression ">=" expression
    expression "<=" expression
```

#### Operators Overloading

* `a == b` is equivalent to `::std::cmp::PartialEq::eq(&a, &b)`
* `a != b` is equivalent to `::std::cmp::PartialEq::ne(&a, &b)`
  * see [`std::cmp::PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)
    trait
    ```rust
    pub trait PartialEq<Rhs = Self>
    where
        Rhs: ?Sized,
    {
        // Required method
        fn eq(&self, other: &Rhs) -> bool;

        // Provided method
        fn ne(&self, other: &Rhs) -> bool { ... }
    }
    ```
* `a > b` is equivalent to `::std::cmp::PartialOrd::gt(&a, &b)`
* `a < b` is equivalent to `::std::cmp::PartialOrd::lt(&a, &b)`
* `a >= b` is equivalent to `::std::cmp::PartialOrd::ge(&a, &b)`
* `a <= b` is equivalent to `::std::cmp::PartialOrd::le(&a, &b)`
  * see [`std::cmp::PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)
    trait
    ```rust
    pub trait PartialOrd<Rhs = Self>: PartialEq<Rhs>
    where
        Rhs: ?Sized,
    {
        // Required method
        fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

        // Provided methods
        fn lt(&self, other: &Rhs) -> bool { ... }
        fn le(&self, other: &Rhs) -> bool { ... }
        fn gt(&self, other: &Rhs) -> bool { ... }
        fn ge(&self, other: &Rhs) -> bool { ... }
    }
    ```

See [Comparison Operators](https://doc.rust-lang.org/reference/expressions/operator-expr.html#comparison-operators)
for greater detail.

### Arithmetic and Logical Expressions

Grammar:
```
arithmetic_or_logical_expression:
    expression "|" expression
    expression "^" expression
    expression "&" expression
    expression "<<" expression
    expression ">>" expression
    expression "+" expression
    expression "-" expression
    expression "*" expression
    expression "/" expression
    expression "%" expression
```

The meaning and associativity of each operator (operators lower in the table
have higher precedence):
| **Operator** | **Meaning** | **Associativity** |
| ------------ | ----------- | ----------------- |
| `\|` | bitwise/logical or | left-to-right |
| `^` | bitwise/logical xor | left-to-right |
| `&` | bitwise/logical and | left-to-right |
| `<<`, `>>` | left shift, right shift | left-to-right |
| `+`, `-` | addition, subtraction | left-to-right |
| `*`, `/`, `%` | multiplication, division, remainder | left-to-right |

#### Operators Overloading

* `a | b` is a syntactical sugar for `BitOr::bitor(a, b)` (see
  [`std::ops::BitOr`](https://doc.rust-lang.org/std/ops/trait.BitOr.html)
  trait)
  ```rust
  pub trait BitOr<Rhs = Self> {
      type Output;

      // Required method
      fn bitor(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a ^ b` is a syntactical sugar for `BitXor::bitxor(a, b)` (see
  [`std::ops::BitXor`](https://doc.rust-lang.org/std/ops/trait.BitXor.html)
  trait)
  ```rust
  pub trait BitXor<Rhs = Self> {
      type Output;

      // Required method
      fn bitxor(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a & b` is a syntactical sugar for `BitAnd::bitand(a, b)` (see
  [`std::ops::BitAnd`](https://doc.rust-lang.org/std/ops/trait.BitAnd.html)
  trait)
  ```rust
  pub trait BitAnd<Rhs = Self> {
      type Output;

      // Required method
      fn bitand(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a << b` is a syntactical sugar for `Shl::shl(a, b)` (see
  [`std::ops::Shl`](https://doc.rust-lang.org/std/ops/trait.Shl.html) trait)
  ```rust
  pub trait Shl<Rhs = Self> {
      type Output;

      // Required method
      fn shl(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a >> b` is a syntactical sugar for `Shr::shr(a, b)` (see
  [`std::ops::Shr`](https://doc.rust-lang.org/std/ops/trait.Shr.html) trait)
  ```rust
  pub trait Shr<Rhs = Self> {
      type Output;

      // Required method
      fn shr(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a + b` is a syntactical sugar for `Add::add(a, b)` (see
  [`std::ops::Add`](https://doc.rust-lang.org/std/ops/trait.Add.html) trait)
  ```rust
  pub trait Add<Rhs = Self> {
      type Output;

      // Required method
      fn add(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a - b` is a syntactical sugar for `Sub::sub(a, b)` (see
  [`std::ops::Sub`](https://doc.rust-lang.org/std/ops/trait.Sub.html) trait)
  ```rust
  pub trait Sub<Rhs = Self> {
      type Output;

      // Required method
      fn sub(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a * b` is a syntactical sugar for `Mul::mul(a, b)` (see
  [`std::ops::Mul`](https://doc.rust-lang.org/std/ops/trait.Mul.html) trait)
  ```rust
  pub trait Mul<Rhs = Self> {
      type Output;

      // Required method
      fn mul(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a / b` is a syntactical sugar for `Div::div(a, b)` (see
  [`std::ops::Div`](https://doc.rust-lang.org/std/ops/trait.Div.html) trait)
  ```rust
  pub trait Div<Rhs = Self> {
      type Output;

      // Required method
      fn div(self, rhs: Rhs) -> Self::Output;
  }
  ```
* `a % b` is a syntactical sugar for `Rem::rem(a, b)` (see
  [`std::ops::Rem`](https://doc.rust-lang.org/std/ops/trait.Rem.html) trait)
  ```rust
  pub trait Rem<Rhs = Self> {
      type Output;

      // Required method
      fn rem(self, rhs: Rhs) -> Self::Output;
  }
  ```

See [Arithmetic and Logical Binary Operators](https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators)
for greater detail.

#### Handling Integer Overflow

* arithmetic operations with integers may overflow
* in debug mode, overflow causes panic
* in `--release` mode, overflow causes unexpected results (caused by modulo
  arithmetic a.k.a. complement wrapping)
* Rust standard library provides methods for primitive types dealing with
  integer arithmetic:
  ```rust
  // wrapping_* methods do modular arithmetic
  assert_eq!(200u8.wrapping_add(100), 44);

  // checked_* methods return None in case of overflow
  assert_eq!(200u8.checked_add(100), None);

  // overflowing_* methods return the value and boolean indicating overflow
  assert_eq!(200u8.overflowing_add(100), (44, true));

  // saturating_* methods do a saturation
  assert_eq!(200u8.saturating_add(100), u8::MAX);
  ```

### Type Cast Expressions

Grammar:
```
type_cast_expression:
    expression "as" type_no_bounds
```

See [Type cast expressions](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions)
for greater detail.

### Negation Expressions

Grammar:
```
negation_expression:
    "-" expression
    "!" expression
```

#### Operators Overloading

* `-a` is a syntactical sugar for `Neg::neg(a)` (see
  [`std::ops::Neg`](https://doc.rust-lang.org/std/ops/trait.Neg.html) trait)
  ```rust
  pub trait Neg {
      type Output;

      // Required method
      fn neg(self) -> Self::Output;
  }
  ```
* `!a` is a syntactical sugar for `Not::not(a)` (see
  [`std::ops::Not`](https://doc.rust-lang.org/std/ops/trait.Not.html) trait)
  ```rust
  pub trait Not {
      type Output;

      // Required method
      fn not(self) -> Self::Output;
  }
  ```

See [Negation operators](https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators)
for greater detail.

### Dereference Expressions

Grammar:
```
dereference_expression:
    "*" expression
```

#### Deref Coercion

* If `T` implements `Deref<Target = U>`, and `v` is a value of type `T`, then:
  * In immutable contexts, `*v` (where `T` is neither a reference nor a raw
    pointer) is equivalent to `*Deref::deref(&v)`.
  * Values of type `&T` are coerced to values of type `&U`.
  * `T` implicitly implements all the methods of the type `U` which take the
    `&self` receiver.
  * See [`std::ops::Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)
    trait:
    ```rust
    pub trait Deref {
        type Target: ?Sized;

        // Required method
        fn deref(&self) -> &Self::Target;
    }
    ```
* If `T` implements `DerefMut<Target = U>`, and `v` is a value of type `T`,
  then:
  * In mutable contexts, `*v` (where `T` is neither a reference nor a raw
    pointer) is equivalent to `*DerefMut::deref_mut(&mut v)`.
  * Values of type `&mut T` are coerced to values of type `&mut U`.
  * `T` implicitly implements all the (mutable) methods of the type `U`.
  * See [`std::ops::DerefMut`](https://doc.rust-lang.org/std/ops/trait.DerefMut.html)
    trait:
    ```rust
    pub trait DerefMut: Deref {
        // Required method
        fn deref_mut(&mut self) -> &mut Self::Target;
    }
    ```

See [The dereference operator](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-dereference-operator)
for greater detail.

### Borrow Expressions

Grammar:
```
borrow_expression:
    ("&" | "&&") "mut"? expression
```
* `&a` produces a reference if `a` is an expression with an associated memory
  location
* memory location associated with `a` is switched to a borrowed state for the
  entire duration of `&a`
  * for `&a` this means that `a` cannot be mutated, but it can be read or
    shared again
  * for `&mut a` this means that `a` cannot be accessed in any other way until
    `&mut a` expires (i.e. having two mutable references to the same place is
    considered invalid)
* if `a` is a value expression (i.e. it has no associated memory location, like
  `3 + 5`), then `&a` or `&mut a` yields a creation of a temporary memory
  location which is then referenced

See [Borrow operators](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)
for greater detail.

### Error Propagation Expressions

Grammar:
```
error_propagation_expression:
    expression "?"
```

See [The question mark operator](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator)
for greater detail.

### Array Index Expressions

Grammar:
```
index_expression:
    expression "[" expression "]"
```

See [Array and slice indexing expressions](https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions)
for greater detail.

### Call Expressions

Grammar:
```
call_expression:
    expression "(" call_params? ")"

call_params:
    expression ("," expression)* ","?
```

See [Call expressions](https://doc.rust-lang.org/reference/expressions/call-expr.html)
for greater detail.

### Field Access Expressions

Grammar:
```
field_expression:
    expression "." identifier

tuple_indexing_expression:
    expression "." integer_literal
```
* a tuple index is compared to the `integer_literal` directly
  * that is, `t.0` is valid but `t.01` or `t.0o0` are invalid
* see [Field access expressions](https://doc.rust-lang.org/reference/expressions/field-expr.html)
  and [Tuple indexing expressions](https://doc.rust-lang.org/reference/expressions/tuple-expr.html#tuple-indexing-expressions)
  for greater detail

### Method-Call Expressions

Grammar:
```
method_call_expression:
    expression "." path_expr_segment "(" call_params? ")"
```

`expression` in the grammar above is called *receiver*.

Here is how receiver and method are resolved:
1. Build a list, *L*, of candidate receiver types.
   1. Repeatedly [dereference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-dereference-operator)
      receiver's expression type, add each encountered type to *L*.
   1. Let *T* be the last type in *L*. Apply [unsized coercion](https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions)
      to *T* and add the result, if any, to *L*.
1. For each `T` in *L*, add `&T` and `&mut T` to *L* immediately after `T`.
1. For every *T* in *L*, search for a visible method with a receiver of type
   *T* in these places:
   1. Methods implemented directly on *T*.
   1. Any of the methods provided by a visible trait implemented by *T*.
      * If *T* is a type parameter, methods provided by trait bounds on *T* are
        looked up first.
      * Then all remaining methods in scope are looked up.
1. If the look up failed or there are ambiguities an error is issued.

See [Method-call expressions](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)
for greater detail.

### Await Expressions

Grammar:
```
await_expression:
    expression "." "await"
```

See [Await expressions](https://doc.rust-lang.org/reference/expressions/await-expr.html)
for greater detail.

### Path Expressions

Grammar:
```
path_expression:
    path_in_expression
    qualified_path_in_expression
```

See [Path expressions](https://doc.rust-lang.org/reference/expressions/path-expr.html)
for greater detail.

### `match` Expressions

Grammar:
```
match_expression:
    "match" scrutinee "{" inner_attribute* match_arms? "}"

scrutinee:
    expression - struct_expression

match_arms:
    (match_arm "=>" (expression_without_block "," | expression_with_block ","?))*
        match_arm "=>" expression ","?
match_arm:
    outer_attribute* pattern match_arm_guard?
match_arm_guard:
    "if" expression
```

A `match` expression branches on a pattern.
* a `scrutinee` expression and patterns must have the same type
* all match arms must have also the same type and this type is the type of the
  whole `match` expression

If a `scrutinee` expression is a value expression:
1. it is first evaluated into a temporary location
1. the resulting value is sequentially (left-to-right, down-to-bottom) compared
   to the patterns until a match is found
   * if the pattern has a match guard associated with it and the pattern
     matches, the match guard is evaluated
     * if it is true, we have a match
     * otherwise, we have no match and the match-finding process continues
       (note that in `p1 | p2 if g`, match guard `if g` is applied to both `p1`
       and `p2`)
     * if the match guard refers to the variables bound within the pattern
       1. a shared reference is taken to the part of the `scrutinee` the
          variable matches on (this prevents mutation inside guards)
       1. this shared reference is then used when accessing the variable during
          the match guard evaluation
       1. if guard evaluates to true, the value is moved or copied from the
          `scrutinee` into the variable
   * every binding in each `|` separated pattern must appear in all of the
     patterns in the arm
1. any variables bound by the first matching pattern are assigned to local
   variables in the arm's block
   * variables are scoped to the match guard and the arm's expression
   * the binding mode (copy, move or reference) depends on the pattern
   * every binding of the same name must have the same type and have the same
     binding mode
1. control enters the block
1. the value returned by the block is the value of the `match` expression

If a `scrutinee` expression is a place expression the same logic as before is
applied with these differences:
* a temporary location is not allocated
* a by-value binding may copy or move from the memory location
* lifetime of a match inherits the lifetime of the place expression

Example:
```rust
#[derive(Clone, Debug)]
enum Foo {
    A,
    B(u8),
    C(u8, u8),
}

use crate::Foo::{A, B, C};

fn test_match(obj: &Object) -> (u8, u8) {
    match *obj {
        A => (0, 0),
        B(x @ 1) | B(x @ 2) => (1, x),
        B(x) | C(_, x) if x >= 3 => (2, x),
        B(x) => (3, x),
        C(x, _) => (4, x),
    }
}

fn main() {
    let objs = vec![
        A,        // prints "(0, 0)"
        B(0),     // prints "(3, 0)"
        B(1),     // prints "(1, 1)"
        B(2),     // prints "(1, 2)"
        B(3),     // prints "(2, 3)"
        B(4),     // prints "(2, 4)"
        C(0, 0),  // prints "(4, 0)"
        C(1, 3),  // prints "(2, 3)"
        C(3, 1),  // prints "(4, 3)"
    ];

    for x in objs {
        println!("{:#?}", test_match(&x));
    }
}
```

See [`match` expressions](https://doc.rust-lang.org/reference/expressions/match-expr.html),
[Patterns](https://doc.rust-lang.org/reference/patterns.html),
[Place Expressions and Value Expressions](https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions),
and [Binding modes](https://doc.rust-lang.org/reference/patterns.html#binding-modes)
for greater detail.

### Block Expressions

Grammar:
```
block_expression:
    "{" inner_attribute* statements? "}"
statements:
    statement+ expression_without_block?
    expression_without_block

async_block_expression:
    "async" "move"? block_expression

unsafe_block_expression:
    "unsafe" block_expression
```

The value and type of `block_expression` is the value and type of `expression`
if it is present. Otherwise the value and type of `block_expression` is `()`.

See [Block expressions](https://doc.rust-lang.org/reference/expressions/block-expr.html)
for greater detail.

### Atomic Expressions

Grammar:
```
atomic_expression:
    underscore_expression
    literal_expression
    tuple_expression
    array_expression
    struct_expression

underscore_expression:
    "_"

literal_expression:
    char_literal
    string_literal
    raw_string_literal
    byte_literal
    byte_string_literal
    raw_byte_string_literal
    integer_literal
    float_literal
    "true" | "false"

tuple_expression:
    "(" tuple_elements? ")"
tuple_elements:
    (expression ",")+ expression?

array_expression:
    "[" array_elements? "]"
array_elements:
    expression ("," expression)* ","?
    expression ";" expression

struct_expression:
    path_in_expression "{" (struct_expr_fields | struct_base)? "}"
    path_in_expression "(" (expression ("," expression)* "'"?)? ")"
    path_in_expression

struct_expr_fields:
    struct_expr_field ("," struct_expr_field)* ("," struct_base | ","?)
struct_expr_field:
    outer_attribute* (
        identifier |
        (identifier | integer_literal) ":" expression
    )
struct_base:
    ".." expression
```
* for `integer_literal` in `struct_expr_field` hold same restriction as for
  `integer_literal` in `tuple_indexing_expression`

See [_ expressions](https://doc.rust-lang.org/reference/expressions/underscore-expr.html),
[Literal expressions](https://doc.rust-lang.org/reference/expressions/literal-expr.html),
[Tuple expressions](https://doc.rust-lang.org/reference/expressions/tuple-expr.html#tuple-expressions),
[Array expressions](https://doc.rust-lang.org/reference/expressions/array-expr.html#array-expressions),
and [Struct expressions](https://doc.rust-lang.org/reference/expressions/struct-expr.html)
for greater detail.

### Grouped Expressions

Grammar:
```
grouped_expression:
    "(" expression ")"
```

See [Grouped expressions](https://doc.rust-lang.org/reference/expressions/grouped-expr.html)
for greater detail.

## Statements

Grammar:
```
statement:
    ";"
    item
    let_statement
    expression_statement
    macro_invocation_semi

item:
    outer_attribute* vis_item
    macro_item

vis_item:
    visibility? (
        declaration_item
        trait
        implementation
        module
        extern_crate
    )
macro_item:
    macro_invocation_semi
    macro_rules_definition

expression_statement:
    expression_without_block ";"
    expression_with_block ";"?
```

See [Statements](https://doc.rust-lang.org/reference/statements.html),
[Item declarations](https://doc.rust-lang.org/reference/statements.html#item-declarations)
and [Items](https://doc.rust-lang.org/reference/items.html) for greater detail.

## Patterns

Grammar:
```
pattern:
    "|"? pattern_no_top_alt ("|" pattern_no_top_alt)*

pattern_no_top_alt:
    pattern_without_range
    range_pattern

pattern_without_range:
    literal_pattern
    identifier_pattern
    wildcard_pattern
    rest_pattern
    reference_pattern
    struct_pattern
    tuple_struct_pattern
    tuple_pattern
    grouped_pattern
    slice_pattern
    path_pattern
    macro_invocation

literal_pattern:
    "true" | "false"
    char_literal
    byte_literal
    string_literal
    raw_string_literal
    byte_string_literal
    raw_byte_string_literal
    "-"? integer_literal
    "-"? float_literal

identifier_pattern:
    "ref"? "mut"? identifier ("@" pattern_no_top_alt)?

wildcard_pattern:
    "_"

rest_pattern:
    ".."

range_pattern:
    range_inclusive_pattern
    range_from_pattern
    range_to_inclusive_pattern
    obsolete_range_pattern

range_inclusive_pattern:
    range_pattern_bound "..=" range_pattern_bound
range_from_pattern:
    range_pattern_bound ".."
range_to_inclusive_pattern:
    "..=" range_pattern_bound
obsolete_range_pattern:
    range_pattern_bound "..." range_pattern_bound

range_pattern_bound:
    char_literal
    byte_literal
    "-"? integer_literal
    "-"? float_literal
    path_expression

reference_pattern:
    ("&" | "&&") "mut"? pattern_without_range

struct_pattern:
    path_in_expression "{" struct_pattern_elements? "}"

struct_pattern_elements:
    struct_pattern_fields ("," struct_pattern_et_cetera?)?
    struct_pattern_et_cetera

struct_pattern_fields:
    struct_pattern_field ("," struct_pattern_field)*
struct_pattern_field:
    outer_attribute* (
        integer_literal ":" pattern |
        identifier ":" pattern |
        "ref"? "mut"? identifier
    )

struct_pattern_et_cetera:
    outer_attribute* ".."

tuple_struct_pattern:
    path_in_expression "(" tuple_struct_items? ")"
tuple_struct_items:
    pattern ("," pattern)* ","?

tuple_pattern:
    "(" tuple_pattern_items? ")"
tuple_pattern_items:
    pattern ","
    rest_pattern
    pattern ("," pattern)+ ","?

grouped_pattern:
    "(" pattern ")"

slice_pattern:
    "[" slice_pattern_items? "]"
slice_pattern_items:
    pattern ("," pattern)* ","?

path_pattern:
    path_expression
```

See [Patterns](https://doc.rust-lang.org/reference/patterns.html) for greater
detail.

## Traits

Grammar:
```
trait:
    "unsafe"? "trait" identifier generic_params? (":" type_param_bounds?)?
        where_clause? "{" inner_attribute* associated_item* "}"

trait_object_type:
    "dyn"? type_param_bounds
trait_object_type_one_bound:
    "dyn"? trait_bound

type_param_bounds:
    type_param_bound ("+" type_param_bound)* "+"?
type_param_bound:
    lifetime
    trait_bound
trait_bound:
    ("?" | for_lifetimes)? type_path
    "(" ("?" | for_lifetimes)? type_path ")"
for_lifetimes:
    "for" generic_params
lifetime_bounds:
    (lifetime "+")* lifetime?
lifetime:
    lifetime_or_label
    "'static"
    "'_"
```

A *trait*:
* describes an abstract interface that types can implement in a separate
  implementation
  * consists of associated functions, types, and constants
    * associated types are members of the trait in the type name space
    * associated functions and constants are members of the trait in the value
      name space
* its declaration defines the trait in the type name space of the trait's
  location
* defines an implicit type parameter `Self` that refers to the type
  implementing this trait
* allows also additional type parameters
  * these type parameters, including `Self`, can be further constrained by
    other traits
* associated functions
  * are not allowed to be `const`
  * if a body is missing, it must be provided by an implementation
  * if a body is present, the associated function's definition is considered as
    default unless overridden by an implementation
  * parameter patterns
    * a parameter pattern can be one of `identifier`, `"mut" identifier`
      (deprecated), `"_"`, `"&" identifier`, or `"&&" identifier`
    * if a body is missing only `identifier` or `"_"` wildcard patterns are
      allowed
    * irrefutable patterns are allowed only if there is a body
* associated constants
  * if a value is missing, it must be provided by an implementation
  * if a value is present, the associated constant's value is considered as
    default unless overridden by an implementation
* associated types
  * must be provided by an implementation
* a visibility annotation is allowed on the syntactical level only
  * it is rejected when the trait is validated
* the `unsafe` keyword at the beginning of a trait item indicates that
  *implementing* the trait may be unsafe
  * the trait implementation must also begin with the `unsafe` keyword
  * correctly implemented unsafe trait is safe to use
  * examples of unsafe traits: `Sync` and `Send`

A *generic trait*:
  * is a trait with type parameters specified (the same syntax as in *generic
    functions* is used)

A *super trait*:
* is declared by trait bounds on the `Self` type of a trait
  * this applies transitively also on the traits and super traits declared in
    those trait bounds
  * a trait cannot be its own super trait
* is required to be implemented for a type to implement a specific trait
* anywhere a generic or trait object is bounded by a trait
  * it has access to the associated items of its super traits
* a trait with a super trait is its super trait's *sub trait*

Example of traits:
```rust
trait Trait {
    fn fn_no_default();
    fn fn_with_default() {}
    fn method_no_default(&self);
    fn method_with_default(&self) {}
    type TypeNoDefault;
    const CONST_NO_DEFAULT: i32;
    const CONST_WITH_DEFAULT: i32 = 42;
}

// Generic trait
trait Seq<T> {
    fn len(&self) -> u32;
    fn elt_at(&self, n: u32) -> T;
    fn iter<F>(&self, f: F) where F: Fn(T);
}

// Super trait
//   - `Shape` is a super trait of `Circle`
trait Shape { fn area(&self) -> f64; }
trait Circle : Shape { fn radius(&self) -> f64; }

// The same as above, but using `where` clause
trait Shape { fn area(&self) -> f64; }
trait Circle where Self: Shape { fn radius(&self) -> f64; }

// Default implementation of `Circle::radius()`
trait Circle where Self: Shape {
    fn radius(&self) -> f64 {
        // A = pi * r^2 => r = (A / pi)^0.5
        (self.area() / std::f64::consts::PI).sqrt()
    }
}

// Super trait method called on a generic parameter
fn print_area_and_radius<C: Circle>(c: C) {
    // Here we call the area method from the super trait `Shape` of `Circle`
    println!("Area: {}", c.area());
    println!("Radius: {}", c.radius());
}

// Super trait method called on a trait object
let circle = Box::new(circle) as Box<dyn Circle>;
let nonsense = circle.radius() * circle.area();
```

Trait and lifetime bounds:
* restrict types and lifetimes of parameters of generic items
  * `+` operator is used to specify more than one bound, for example:
    * `T: Copy + Send + 'static` restrict `T` to satisfy `Copy` and `Send`
      traits and to have `'static` lifetime
* are also used to name trait objects
* can be provided on any type in a `where` clause
  * shortcuts:
    * `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}` (bounds
      written after declaring a generic parameter)
    * `trait Circle: Shape {}` is equivalent to `trait Circle where Self: Shape
      {}` (bounds as super traits)
    * `trait A { type B: Copy; }` is equivalent to `trait A where Self::B: Copy
      { type B; }` (bounds on associated types)
* bounds on an item must be satisfied when using the item
* bounds can be used to determine that a trait is implemented for a type
* bounds that don't use the item's parameter or higher-ranked lifetimes are
  checked when the item is defined
* `Copy` and `Clone` cannot be used as bounds on a mutable reference, trait
  object, or slice
* `Sized` cannot be used as a bound on a trait object or a slice
* `?Sized` relax the implicit `Sized` trait bound
  * can only be used for type parameters or associated types
  * for now, `?` can only be used together with `Sized`
* lifetime bounds
  * can be applied to types or to other lifetimes
  * the bound `'a: 'b`
    * is read as `'a` *outlives* `'b`
    * means that `'a` lasts at least as long as `'b`, e.g. `&'a ()` is valid
      whenever `&'b ()` is valid
  * `T: 'a` means that all lifetime parameters of `T` outlive `'a`, for example
    (`'a` is unconstrained lifetime parameter):
    * `i32: 'static` is satisfied (`i32` lives as long as `'static`)
    * `&'static str: 'a` is satisfied (`'static` outlives `'a`)
    * `Vec<&'a ()>: 'static` is not satisfied (elements of the vector may live
      shorter than `'static`)
  * sometimes, lifetime bounds can be inferred (see examples below)
    * implied/inferred bounds are added for all parameters and outputs of a
      function
    * lifetime bounds are also inferred for type definitions and `impl` blocks
      for any type
* higher-ranked trait bounds (over lifetimes)
  * specify a bound that is true for all lifetimes

Example of trait bounds:
```rust
trait GObject {
    const PATTERN: u32;
    type BrushType;
    fn name() -> &'static str;
    fn draw(&self, surface: Surface);
}

fn render<T: GObject>(surface: Surface, obj: T) {
    // `T` can use `GObject`'s constants and types
    let brush = create_brush::<T::BrushType>(T::PATTERN);
    // `obj` can invoke `GObject`'s methods
    obj.draw(surface.with_brush(brush));
}

fn copy_and_render<T: Copy>(surface: Surface, obj: T) where T: GObject {
    // Copy `obj` because `T: Copy`
    let cobj = obj;
    // Can use `render` because `T: GObject`
    render(surface, cobj);
}

struct Image<T: GObject>(T, T);

fn render_image<U: GObject>(surface: Surface, img: Image<U>) {
    // `Image<U>` is well-formed because `U: GObject`
    render(surface, img.0);
    // `render` can use `img.1` because `U: GObject`
    render(surface, img.1);
}
```

Example of lifetime bounds:
```rust
fn f<'a, 'b>(x: &'a i32, mut y: &'b i32) where 'a: 'b {
    // Since `'a: 'b`, `&'a i32` is a subtype of `&'b i32` so the assignment
    // is ok
    y = x;
    // This is ok since `'a` outlives `'b` and hence `r` will be no referring
    // to possibly invalid and outdated data
    let r: &'b &'a i32 = &&0;
}
```

Examples of inferred lifetime bounds:
* `&'a T` is valid if and only if `T: 'a`, so the lifetime bound of `T` is `'a`
  ```rust
  fn requires_t_outlives_a<'a, T>(x: &'a T) {}
  ```
* inside `requires_t_outlives_a` it is assumed that `T: 'a` even this is not
  explicitly specified
  ```rust
  fn requires_t_outlives_a_not_implied<'a, T: 'a>() {}

  fn requires_t_outlives_a<'a, T>(x: &'a T) {
      // This compiles, because `T: 'a` is implied by
      // the reference type `&'a T`
      requires_t_outlives_a_not_implied::<'a, T>();
  }

  fn not_implied<'a, T>() {
      // This errors, because `T: 'a` is not implied by
      // the function signature
      requires_t_outlives_a_not_implied::<'a, T>();
  }
  ```
* trait bounds still have to be added explicitly
  ```rust
  use std::fmt::Debug;
  struct IsDebug<T: Debug>(T);
  // Error: `T` doesn't implement `Debug`
  fn doesnt_specify_t_debug<T>(x: IsDebug<T>) {}
  ```
* type definitions and `impl` blocks
  ```rust
  struct Struct<'a, T> {
      // Here it is inferred that `T: 'a`
      field: &'a T,
  }

  enum Enum<'a, T> {
      // Same here. `T: 'a` is inferred for the whole `enum` and thus it must
      // be satisfied for all its variants
      SomeVariant(&'a T),
      OtherVariant,
  }

  trait Trait<'a, T: 'a> {}

  // This would error because `T: 'a` is not implied by any type
  // in the `impl` header
  impl<'a, T> Trait<'a, T> for () {}

  // This compiles as `T: 'a` is implied by the self type `&'a T`
  impl<'a, T> Trait<'a, T> for &'a T {}
  ```

Examples of higher-ranked lifetime bounds:
```rust
fn compare<T>(x: i32) where for<'a> &'a T: PartialEq<i32> {
    // ...
}

// In order to compare `&'a T` with any lifetime with `i32`, `PartialEq<i32>`
// must be implemented for `&'a T`:
impl<'a> PartialEq<i32> for &'a T {
    // ...
}

fn call_on_ref_zero<F>(f: F) where for<'a> F: Fn(&'a i32) {
    let zero = 0;
    // `&zero` has shorter lifetime than any possible lifetime parameter on the
    // function and hence only higher-ranked lifetime bounds can be used here
    f(&zero);
}

// This function is equivalent to the last one, except that the scope of the
// lifetime parameter extends only to the end of the `Fn(&'a i32)` trait (in
// the previous example the scope of the lifetime parameter was the whole
// `F: Fn(&'a i32)` bound)
fn call_on_ref_zero<F>(f: F) where F: for<'a> Fn(&'a i32) {
    let zero = 0;
    f(&zero);
}
```

A `dyn` compatible trait:
* formerly known as an *object safe* trait (see
  [RFC 255](https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md)
  and [RFC 546](https://github.com/rust-lang/rfcs/blob/master/text/0546-Self-not-sized-by-default.md))
* can be the base trait of a trait object
* has the following qualities:
  * all super traits must also be `dyn` compatible
  * `Sized` must not be a super trait (it must not require `Self: Sized`)
  * associated constants are not allowed
  * associated types with generics are not allowed
  * all associated functions must
    * either be dispatchable from a trait object
    * or be explicitly non-dispatchable
  * a dispatchable associated function
    * must not have any type parameters
      * lifetime parameters are allowed
    * must be a method that does not use `Self` except in the type of the
      receiver
    * must have a receiver with one of the following types: `&Self` (i.e.
      `&self`), `&mut Self` (i.e. `&mut self`), `Box<Self>`, `Rc<Self>`,
      `Arc<Self>`, `Pin<P>` where `P` is one of the previous types
    * must not have an opaque return type, that is
      * it must not be an `async fn` (has a hidden `Future` return type)
      * it must not have a return position `impl Trait` type (e.g. `fn
        example(&self) -> impl Trait`)
    * must not have a `where Self: Sized` bound (receiver type of `Self` (i.e.
      `self`) implies this)
  * an explicitly non-dispatchable associated function
    * must have a `where Self: Sized` bound (receiver type of `Self` (i.e.
      `self`) implies this)

Examples of `dyn` compatible traits:
```rust
// `dyn` compatible trait - all associated functions are dispatchable
trait TraitMethods {
    fn by_ref(self: &Self) {}
    fn by_ref_mut(self: &mut Self) {}
    fn by_box(self: Box<Self>) {}
    fn by_rc(self: Rc<Self>) {}
    fn by_arc(self: Arc<Self>) {}
    fn by_pin(self: Pin<&Self>) {}
    fn with_lifetime<'a>(self: &'a Self) {}
    fn nested_pin(self: Pin<Arc<Self>>) {}
}

// `dyn` compatible trait - all associated functions are explicitly
// non-dispatchable (recall that an associated function that is not
// dispatchable must have a `where Self: Sized` bound)
trait NonDispatchable {
    // Non-dispatchable (not a method)
    fn foo() where Self: Sized {}
    // Non-dispatchable (use `Self`, which is not known until runtime)
    fn returns(&self) -> Self where Self: Sized;
    // Non-dispatchable (use `Self` in `other`, which may be a different
    // concrete type of the receiver)
    fn param(&self, other: Self) where Self: Sized {}
    // Non-dispatchable (has a type parameter, `T`; generics are not compatible
    // with virtual tables)
    fn typed<T>(&self, x: T) where Self: Sized {}
}
```

Examples of `dyn` non-compatible traits:
```rust
trait DynIncompatible {
    // Error: have associated constant
    const CONST: i32 = 1;

    // Error: associated function is not a method and thus it is not
    // dispatchable which means that a `where Self: Sized` bound is required,
    // which is missing
    fn foo() {}
    // Error: `Self` used in return type implies non-dispatchable method, but a
    // `where Self: Sized` bound is missing
    fn returns(&self) -> Self;
    // Error: a generic type parameter implies non-dispatchable method, but a
    // `where Self: Sized` bound is missing
    fn typed<T>(&self, x: T) {}
    // Error: only `Rc<Self>` is supported at now, which implies that the
    // method is non-dispatchable and hence a `where Self: Sized` bound is
    // required
    fn nested(self: Rc<Box<Self>>) {}
}

// `Sized is a super trait
trait TraitWithSize where Self: Sized {}

// `Self` as a type parameter in the super trait confuses the compiler:
//   * `Self` is not known until runtime and thus a virtual table cannot be
//     build
// Hence the super trait is not `dyn` compatible
trait Super<A> {}
trait WithSelf: Super<Self> where Self: Sized {}
```

### Trait Objects

A *trait object*:
* an opaque value of another type that implements a set of traits consisting
  of:
  * a `dyn` compatible base trait
  * any number of its auto traits
  * any super traits of the base trait
* the layout of a trait object is same as the layout of its value
* is written as the keyword `dyn` followed by a set of trait bounds with the
  following restrictions:
  * no more than one non-auto trait is allowed
  * no more than one lifetime is allowed
    * a lifetime is sometimes required when a trait object contains references
    * in some cases, a lifetime can be inferred
  * no opt-out bounds (e.g. `?Sized`) are allowed
  * paths to traits may be parenthesized
* two trait objects alias each other if:
  * the base traits alias each other
  * the sets of auto traits are the same
  * the lifetime bounds are the same
* is a dynamically sized type (DST)
  * it is used behind some type of pointer, e.g. `&dyn Trait` or `Box<dyn
    Trait>`
* permits late binding of methods
  * an instance of a pointer to a trait object includes:
    * a pointer to an instance of a type `T` that implements `SomeTrait`
    * a *virtual method table* (*vtable*), which contains, for each method of
      `SomeTrait` and its super traits that `T` implements, a pointer to `T`'s
      implementation (i.e. a function pointer)

Examples of trait objects:
```rust
// These are all valid trait object signatures:
// * `dyn Trait`
// * `dyn Trait + Send`
// * `dyn Trait + Send + Sync`
// * `dyn Trait + 'static`
// * `dyn Trait + Send + 'static`
// * `dyn Trait +`
// * `dyn 'static + Trait`
// * `dyn (Trait)`

trait Printable {
    fn stringify(&self) -> String;
}

impl Printable for i32 {
    fn stringify(&self) -> String { self.to_string() }
}

fn print(a: Box<dyn Printable>) {
    println!("{}", a.stringify());
}

fn main() {
    print(Box::new(10) as Box<dyn Printable>);
}
```

### Dynamically Sized Types

A dynamically sized type (DST):
* has a size known only during run-time
* can only be used
  * in pointer types
    * a pointer to a DST is sized but has twice the size of a pointer to a
      sized types
    * a pointer to a slice consists of a pointer to the array and the number of
      elements of the slice
    * a pointer to a trait object consists of a pointer to its data and a
      pointer to a virtual table
  * as type arguments to generic type parameters having the special `?Sized`
    bound
  * for associated type definitions when the corresponding associated type
    declaration has a `?Sized` bound
  * as `T` in `impl Trait for T`
    * in this case, `Self: ?Sized` is the default in trait definitions, unlike
      with generic type parameters
  * in `struct`s as the last field
    * this turns `struct` itself into a DST
* variables, function parameters, `const` items, and `static` items must be
  `Sized`
* examples: slices, trait objects

### `Sized` Trait

* indicates that the size of the implementing type is known at compile-type
* is implemented by all types with a fixed size automatically by the compiler
* any type parameter (except `Self` in traits) or associated type has the
  `Sized` bound by default
* implicit `Sized` bounds may be relaxed by using the special `?Sized` bound

See [Traits](https://doc.rust-lang.org/reference/items/traits.html),
[Trait objects](https://doc.rust-lang.org/reference/types/trait-object.html),
[Type Layout](https://doc.rust-lang.org/reference/type-layout.html),
[Trait and lifetime bounds](https://doc.rust-lang.org/reference/trait-bounds.html),
[Lifetime elision](https://doc.rust-lang.org/reference/lifetime-elision.html),
[Special types and traits](https://doc.rust-lang.org/reference/special-types-and-traits.html),
[Dynamically Sized Types](https://doc.rust-lang.org/reference/dynamically-sized-types.html),
[Associated Items](https://doc.rust-lang.org/reference/items/associated-items.html),
[Constant items](https://doc.rust-lang.org/reference/items/constant-items.html),
[Static items](https://doc.rust-lang.org/reference/items/static-items.html),
[Namespaces](https://doc.rust-lang.org/reference/names/namespaces.html),
[Scopes](https://doc.rust-lang.org/reference/names/scopes.html),
[Visibility and Privacy](https://doc.rust-lang.org/reference/visibility-and-privacy.html),
[Type parameters](https://doc.rust-lang.org/reference/types/parameters.html),
[Generic parameters](https://doc.rust-lang.org/reference/items/generics.html),
[Implementations](https://doc.rust-lang.org/reference/items/implementations.html),
[Variables](https://doc.rust-lang.org/reference/variables.html),
[Functions](https://doc.rust-lang.org/reference/items/functions.html),
[Patterns](https://doc.rust-lang.org/reference/patterns.html),
[Unsafety](https://doc.rust-lang.org/reference/unsafety.html),
[Slice types](https://doc.rust-lang.org/reference/types/slice.html),
[Pointer types](https://doc.rust-lang.org/reference/types/pointer.html),
[`Box`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html),
[`Rc`](https://doc.rust-lang.org/alloc/rc/struct.Rc.html),
[`Arc`](https://doc.rust-lang.org/alloc/sync/struct.Arc.html),
[`Pin`](https://doc.rust-lang.org/core/pin/struct.Pin.html),
[`Copy`](https://doc.rust-lang.org/std/marker/trait.Copy.html),
[`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html), and
[`Sized`](https://doc.rust-lang.org/std/marker/trait.Sized.html) for greater
detail.

## Implementations

Grammar:
```
implementation:
    inherent_impl
    trait_impl

inherent_impl:
    "impl" generic_params? type where_clause?
        "{" inner_attribute* associated_item* "}"
trait_impl:
    "unsafe"? "impl" generic_params? "!"? type_path "for" type where_clause?
        "{" inner_attribute* associated_item* "}"

associated_item:
    outer_attribute* (
        macro_invocation_semi |
        (visibility? (type_alias | constant_item | function))
    )

impl_trait_type:
    "impl" type_param_bounds

impl_trait_type_one_bound:
    "impl" trait_bound
```

An implementation associates an item definition with a concrete type.
* this happens inside of `impl` block
* contain functions that belong
  * to an instance of the type that is being implemented
  * or to the type statically
* multiple `impl` blocks per one implementing type are possible
* attributes (both inner and outer) are allowed
  * inner attributes that have meaning here are `cfg`, `deprecated`, `doc`, and
    the lint check attributes

An associated item:
* is an item declared in a trait or defined in an implementation
* can be an associated type, an associated constant, or an associated function
  or method
* comes in two varieties: declaration or definition

Inherent implementations:
* the nominal type is called the *implementing type*
* the associable items are the *associated items* to the implementing type
* associate the contained items to the implementing type
* can contain associated functions, including methods, and associated constants
* cannot contain associated type aliases
* the path to an associated item = a path to the implementing type + the
  associated item's identifier
* a type can also have multiple inherent implementations
* an implementing type must be defined within the same crate as the original
  type definition

Trait implementations:
* the trait is known as the *implemented trait*
* must define all non-default associated items declared by the implemented
  trait
* may redefine default associated items defined by the implemented trait
* cannot define any other items
* the path to an associated item = `<` + a path to the implementing type + `as`
  + a path to the trait + `>` + the associated item's path
* unsafe traits require the trait implementation to begin with the `unsafe`
  keyword
* **orphan rules check:**
  * given `impl<P1..=Pn> Trait<T1..=Tn> for T0`
  * an `impl` is valid only if at least one of the following is true:
    1. `Trait` is a *local trait*
    1. all of:
       1. at least one of the types `T0..=Tn` must be a *local type*; let `Ti`
          be the first such type
       1. no *uncovered type* parameters `P1..=Pn` may appear in `T0..Ti`
          (excluding `Ti`)
  * fundamental types are special:
    * the `T` in `Box<T>` is not considered covered
    * `Box<LocalType>` is considered local
* two trait implementations *overlap* when:
  * there is a non-empty intersection of the traits the implementation is for
  * the implementations can be instantiated with the same type
* a trait implementation is considered *incoherent* if
  * either the orphan rules check fails
  * or there are overlapping implementation instances
* **glossary**
  * a **local trait** is a trait which was defined in the current crate
    * applied type arguments do not affect locality
  * a **local type** is a `struct`, `enum`, or `union` which was defined in the
    current crate
    * this is not affected by applied type arguments
      * `struct Foo` is considered local, but `Vec<Foo>` is not
      * `LocalType<ForeignType>` is local
    * type aliases do not affect locality
  * an **uncovered type** is a type which does not appear as an argument to
    another type, e.g. `T` is uncovered, but `T` in `Vec<T>` is covered by
    `Vec`
  * a **blanket implementation** is any implementation where a type appears
    uncovered, e.g. `impl<T> Bar<T> for Vec<T>` is a blanket implementation
    whereas `impl<T> Bar<Vec<T>> for Vec<T>` is not (all instances of `T` are
    covered by `Vec`)
  * a **fundamental type constructor** is a type where implementing a blanket
    implementation over it is a breaking change
    * `&`, `&mut`, `Box`, and `Pin` are fundamental
    * if `T` is local, `&T`, `&mut T`, `Box<T>`, and `Pin<T>` are also local
    * fundamental type constructors cannot cover other types, i.e. `T` in `&T`,
      `&mut T`, `Box<T>`, and `Pin<T>` is not considered covered

Generic implementations:
* an implementation can take generic parameters, which can be used in the rest
  of the implementation
* generic parameters *constrain* an implementation if the parameter appears at
  least once in one of:
  * the implemented trait, if it has one
    * in `impl<T> GenericTrait<T> for i32 {}`, `T` appears in the implemented
      trait
  * the implementing type
    * in `impl<T> Trait for GenericStruct<T> {}`, `T` appears in the
      implementing type
  * as an associated type in the bounds of a type that contains another
    parameter that constrains the implementation
    * in `impl<T, U> GenericTrait<U> for u32 where U: HasAssocType<Ty = T> {}`,
      `T` is used as an associated type in a bound for type `U`, which itself
      constrains the implementation (i.e. appears in the implemented trait)
    * in `impl<T, U> GenericStruct<U> where (U, isize): HasAssocType<Ty = T>
      {}`, `T` is used as an associated type in a bound for type `(U, isize)`
      which contains `U` that constrains the implementation (appears in
      `GenericStruct<U>`)
* type and `const` parameters must always constrain the implementation
  * error in `impl<T> Struct {}`: `T` does not constrain `Struct`
  * error in `impl<const N: usize> Struct {}`: `T` does not constrain `Struct`
  * error in `impl<T, U> Struct where U: HasAssocType<Ty = T> {}`: `T` is used
    as an associated type in the bounds for `U`, but `U` does not constrain
    `Struct`
  * error in `impl<T, U> GenericTrait<U> for u32 where U: GenericTrait<T> {}`:
    `T` is used in the bounds, but not as an associated type
* lifetimes must constrain the implementation if the lifetime is used in an
  associated type
  * in `impl<'a> Struct {}`: lifetime is not used in an associated type
  * error in `impl<'a> HasAssocType for Struct { type Ty = &'a Struct; }`: `'a`
    is used in an associated type, but it does not constrain the implementation
    (does not appear neither in `HasAssocType` nor in `Struct`)

See [Implementations](https://doc.rust-lang.org/reference/items/implementations.html),
[Traits](https://doc.rust-lang.org/reference/items/traits.html),
[Trait and lifetime bounds](https://doc.rust-lang.org/reference/trait-bounds.html),
[Associated Items](https://doc.rust-lang.org/reference/items/associated-items.html),
[Generic parameters](https://doc.rust-lang.org/reference/items/generics.html),
[Paths](https://doc.rust-lang.org/reference/paths.html),
[Attributes](https://doc.rust-lang.org/reference/attributes.html),
[Diagnostic attributes](https://doc.rust-lang.org/reference/attributes/diagnostics.html),
[The `#[doc]` attribute](https://doc.rust-lang.org/rustdoc/write-documentation/the-doc-attribute.html),
[Conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html),
[`Box`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html),
and [`Pin`](https://doc.rust-lang.org/core/pin/struct.Pin.html) for greater
detail.

### Associated Functions and Methods

Associated functions are functions associated with a type.

When the associated function `function_name` is declared on a trait `Trait`:
* it can be called with a path `Trait::function_name`
  * this is substituted for `<_ as Trait>::function_name`
* given
  ```rust
  trait Num {
      fn from_i32(n: i32) -> Self;
  }

  impl Num for f64 {
      fn from_i32(n: i32) -> f64 { n as f64 }
  }
  ```
  the following are equivalent:
  ```rust
  let _: f64 = Num::from_i32(42);
  let _: f64 = <_ as Num>::from_i32(42);
  let _: f64 = <f64 as Num>::from_i32(42);
  let _: f64 = f64::from_i32(42);
  ```

Methods are associated functions with `self` as the first parameter. The type
of `self`, `S`, can be specified, but it undergoes the following restrictions:
* Let `T` be an implementing type and `'a` be an arbitrary lifetime.
* Then `S` is one of `Self` or `P`, where
  * `Self` refers to a type resolving to `T`, such as alias of `T`, `Self`, or
    associated type projections resolving to `T`;
  * `P` is one of `& 'a S`, `& 'a mut S`, `Box<S>`, `Rc<S>`, `Arc<S>`, or
    `Pin<S>`.

Methods can be invoked:
* using method call operator, e.g. `x.foo()`
* using usual function call notation

When `self` has no type specified, then
* `self` is equivalent to `self: Self`
* `& 'a self` is equivalent to `self: & 'a Self`
* `& 'a mut self` is equivalent to `self: & 'a mut Self`
* lifetime is usually elided with this shorthand notation

Like functions, method parameters can have attributes.

Explanation on example:
```rust
#[derive(Debug)]
struct FsItem {
    name: String,
    size: usize,
}

impl FsItem {
    fn new() -> Self {
        Self {
            name: String::from(""),
            size: 0usize,
        }
    }

    fn create(name: String, size: usize) -> FsItem {
        FsItem { name, size }
    }

    fn name(&self) -> String {
        String::from(self.name.as_str())
    }

    fn size(&self) -> usize {
        self.size
    }

    fn rename(&mut self, name: String) {
        self.name = name;
    }
}

fn main() {
    let mut fsitem1 = FsItem::new();
    let fsitem2 = FsItem::create(String::from("/etc/fsitem2"), 16);

    println!("{fsitem1:#?}");
    println!("{fsitem2:#?}");

    println!("fsitem1 = {{ {}, {} }}", fsitem1.name(), fsitem1.size());

    fsitem1.rename(String::from("/etc/fsitem1"));

    println!("fsitem1 = {{ {}, {} }}", fsitem1.name(), fsitem1.size());
}
```
* `impl FsItem` block encloses functions and methods definitions associated
  with `struct FsItem`
* `new()` and `create()` are associated functions of `struct FsItem` and as
  such their path must be specified to call them: `FsItem::new()`,
  `FsItem::create()`
* `name()`, `size()`, and `rename()` are methods
  * they are called using [method-call expression](https://doc.rust-lang.org/reference/expressions/method-call-expr.html),
    e.g. `fsitem1.name()`
* `Self` refers to the implementing type, here `struct FsItem`
* `self` refers to the object of implementing type and it is an implicit
  parameter to the method
  * e.g. `x.f(a, b)` translates to `T::f(x, a, b)` where `T` is the type of the
    receiver or trait and `x` matches with `self`
* `mut` before `self` denotes that a method modifies the object referred by
  `self`
* `&` is necessary if the object referred by `self` is borrowed more than once
  * e.g. `fsitem1` is borrowed by `name()` and by `size()`

### Associated Types

Associated types:
* are type aliases associated with another type
* cannot be defined in inherent implementations
* cannot have default implementation in traits
* has implicit `Sized` bound
  * can be relaxed using the special `?Sized` bound
* can be used in function signatures inside the trait
  * besides the associated type, an implementation of the trait must also
    provide definitions of these functions
    ```rust
    // Associated type is used in `insert`
    trait Container {
        type E;
        fn empty() -> Self;
        fn insert(&mut self, elem: Self::E);
    }

    // Implementation
    impl<T> Container for Vec<T> {
        type E = T;
        fn empty() -> Vec<T> { Vec::new() }
        fn insert(&mut self, x: T) { self.push(x); }
    }
    ```

An associated type declaration:
* declares a signature for associated type definitions
* it is written in one of the following forms:
  ```rust
  // `Assoc`       - the name of the associated type
  // `Params`      - a comma-separated list of type, lifetime or `const`
  //                 parameters
  // `Bounds`      - a plus-separated list of trait bounds that the associated
  //                 type must meet
  // `WhereBounds` - a comma-separated list of bounds that the parameters must
  //                 meet
  type Assoc;
  type Assoc: Bounds;
  type Assoc<Params>;
  type Assoc<Params>: Bounds;
  type Assoc<Params> where WhereBounds;
  type Assoc<Params>: Bounds where WhereBounds;
  ```
* the optional trait bounds must be fulfilled by the implementations of the
  type alias

An associated type definition:
* defines a type alias for the implementation of a trait on a type
* it is written in one of the following forms:
  ```rust
  type Assoc = Type;
  // `Type` here may reference `Params`
  type Assoc<Params> = Type;
  type Assoc<Params> = Type where WhereBounds;
  // Deprecated, prefer the form above
  type Assoc<Params> where WhereBounds = Type;
  ```

Type referencing:
* given
  ```rust
  trait Trait {
      // Associated type declaration
      type Assoc;
  }

  struct Item;

  struct OtherItem;

  impl Trait for Item {
      // Associated type definition
      type Assoc = OtherItem;
  }
  ```
  * then `<Item as Trait>::Assoc` is an alias of `OtherItem`
  * note that if `Item` is a type parameter then also `Item::Assoc` can be used
    in type parameters
* with generics:
  ```rust
  struct ArrayLender<'a, T>(&'a mut [T; 16]);

  trait Lend {
      // Generic parameters and `where` clauses are allowed. Such an associated
      // types are often referred to as generic associated types, or GATs
      type Lender<'a> where Self: 'a;

      fn lend<'a>(&'a mut self) -> Self::Lender<'a>;
  }

  impl<T> Lend for [T; 16] {
      // GAT definition
      type Lender<'a> = ArrayLender<'a, T> where Self: 'a;

      fn lend<'a>(&'a mut self) -> Self::Lender<'a> {
          ArrayLender(self)
      }
  }

  // If the type `Thing` has an associated type `Item` from a trait `Trait`
  // with the generics `<'a>`, then the type can be named like
  // `<Thing as Trait>::Item<'x>`, where `'x` is some lifetime in scope. In
  // this case, `'x` will be used wherever `'a` appears in the associated type
  // definitions on `impl`s. In the example below:
  //
  //   * `T` has an associated type, `Lender`
  //   * `Lender` is from `Lend` trait
  //   * `Lender` has the generics `<'a>`
  //   * the lifetime in scope is `'a`
  //   * the `Lender` associated type can be then named as
  //     `<T as Lend>::Lender<'a>`; `'a` from `borrow` is used via `Lender<'a>`
  //     as the lifetime bound for `Lend` and also for `T`
  //
  fn borrow<'a, T: Lend>(array: &'a mut T) -> <T as Lend>::Lender<'a> {
      array.lend()
  }

  fn main() {
      let mut array = [0usize; 16];
      let lender = borrow(&mut array);
  }
  ```
* given
  ```rust
  trait Example {
      type Output<T>: Ord where T: Debug;
  }
  ```
  and the reference `<X as Example>::Output<Y>`, then
  * the associated type itself must be `Ord`
  * the type `Y` must be `Debug`

Required `where` clauses on GATs:
* see [Required bounds](https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html)
* reason: to maximize the allowed definitions of the associated type in `impl`s
* the rule of thumb: any clauses that *can be proven to hold* on functions
  (using the parameters of the function or trait) where a GAT appears as an
  input or output must also be written on the GAT itself
  * when there are multiple functions in a trait that use the GAT, then the
    *intersection* of the bounds from the different functions are used
  * the bounds on associated types also propagate required `where` clauses
  * any explicit uses of `'static` on GATs in the trait do not count towards
    the required bounds
* examples:
  ```rust
  // Example 1
  //
  // From `&'a mut self` at (2), it is inferred that `Self: 'a`. Therefore,
  // `Item` at (1) must be provided with the bound `where Self: 'x`
  trait LendingIterator {
      type Item<'x> where Self: 'x;                 // (1)
      fn next<'a>(&'a mut self) -> Self::Item<'a>;  // (2)
  }

  // Example 2
  //
  // From `&'a T` at (2), it is inferred that `T: 'a`. From (3), nothing is
  // inferred. The intersection of bounds from (2) and (3) is then the empty
  // set and hence no bounds at (1) are required
  trait Check<T> {
      type Checker<'x>;                                         // (1)
      fn create_checker<'a>(item: &'a T) -> Self::Checker<'a>;  // (2)
      fn do_check(checker: Self::Checker<'_>);                  // (3)
  }

  // Example 3
  //
  // From `&'a T` at (2), it is inferred that `T: 'a`. Therefore, `Checker` at
  // (1) must be provided with the bound `where T: 'x`
  trait Check<T> {
      type Checker<'x> where T: 'x;                             // (1)
      fn create_checker<'a>(item: &'a T) -> Self::Checker<'a>;  // (2)
  }

  // Example 4
  //
  // From `&'a self` at (3), it is inferred that `Self: 'a`. Therefore, `Item`
  // at (1) must be provided with the bound `where Self: 'a`. Since `Item` is
  // used in the `Iterator` bounds at (2), `where Self: 'a` is also required
  // there
  trait Iterable {
      type Item<'a> where Self: 'a;                                       // (1)
      type Iterator<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;  // (2)
      fn iter<'a>(&'a self) -> Self::Iterator<'a>;                        // (3)
  }

  // Example 5
  //
  // Explicit use of `'static` at (2) does not count towards the required
  // bounds
  trait StaticReturn {
      type Y<'a>;                         // (1)
      fn foo(&self) -> Self::Y<'static>;  // (2)
  }
  ```

### Associated Constants

* constants associated with a type
* a declaration declares a signature for associated constant definitions
  * it can provide the default value
* a definition defines a constant associated with a type
  * undergoes constant evaluation only when referenced
  * if it contains generic parameters, the evaluation is done after
    monomorphization
* examples:
  ```rust
  struct StructA;
  struct StructB;
  struct StructC;
  struct StructD;
  struct GenericStruct<const ID: i32>;

  trait ConstantId {
      const ID: i32;
  }

  trait ConstantIdDefault {
      const ID: i32 = 1;
  }

  impl ConstantId for StructA {
      const ID: i32 = 1;
  }

  impl ConstantIdDefault for StructB {}

  impl ConstantIdDefault for StructC {
      const ID: i32 = 5;
  }

  impl StructD {
      // Definition not immediately evaluated
      const PANIC: () = panic!("compile-time panic");
  }

  impl<const ID: i32> GenericStruct<ID> {
      // Definition not immediately evaluated
      const NON_ZERO: () = if ID == 0 {
          panic!("contradiction")
      };
  }

  fn main() {
      assert_eq!(StructA::ID, 1);
      assert_eq!(StructB::ID, 1);
      assert_eq!(StructC::ID, 5);

      // Referencing `Struct::PANIC` causes compilation error
      let _ = Struct::PANIC;

      // Fine, `ID` is not 0
      let _ = GenericStruct::<1>::NON_ZERO;

      // Compilation error from evaluating `NON_ZERO` with `ID = 0`
      let _ = GenericStruct::<0>::NON_ZERO;
  }
  ```

See [Associated Items](https://doc.rust-lang.org/reference/items/associated-items.html),
[Generic parameters](https://doc.rust-lang.org/reference/items/generics.html),
[Constant items](https://doc.rust-lang.org/reference/items/constant-items.html),
[Constant evaluation](https://doc.rust-lang.org/reference/const_eval.html),
[Function item types](https://doc.rust-lang.org/reference/types/function-item.html),
[Functions](https://doc.rust-lang.org/reference/items/functions.html),
[Method-call expressions](https://doc.rust-lang.org/reference/expressions/method-call-expr.html),
[Paths](https://doc.rust-lang.org/reference/paths.html),
[Implementations](https://doc.rust-lang.org/reference/items/implementations.html),
[Type aliases](https://doc.rust-lang.org/reference/items/type-aliases.html),
[`Sized`](https://doc.rust-lang.org/core/marker/trait.Sized.html),
[`Box`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html),
[`Rc`](https://doc.rust-lang.org/alloc/rc/struct.Rc.html),
[`Arc`](https://doc.rust-lang.org/alloc/sync/struct.Arc.html),
and [`Pin`](https://doc.rust-lang.org/core/pin/struct.Pin.html) for greater
detail.

### `impl` Traits

`impl Trait`:
* provides ways to specify unnamed but concrete types that implement a specific
  trait
* it can appear both as argument/parameter and return type
  * in an parameter/argument position acts as an anonymous type parameter
  * in the return position acts as an abstract return type
* it can only appear as a parameter or return type of a non-`extern`
  * it cannot be the type of
    * a `let` binding
    * a field type
  * it cannot appear inside a type alias

An anonymous type parameter:
* provides trait bounds that must be satisfied by a caller
  * the function can only use the methods available through the trait bounds of
    the anonymous type parameter
* is a very similar to a generic type parameter, except
  * its type is anonymous
  * it does not appear in the `generic_params` list
  * caller has no option to explicitly specify a type as in case of generic
    type parameters
* example:
  ```rust
  // Almost equivalent to `fn foo<T: Trait>(x: T) {}`
  fn foo(x: impl Trait) {}
  ```

An abstract return type:
* stands in for another concrete type where the caller may only use the methods
  declared by the specified `Trait`
* each possible return value from the function must resolve to the same
  concrete type
  * unlike generic parameters, a concrete type is chosen by a function, not by
    the caller
    ```rust
    // `T` is chosen be the caller
    fn foo<T: Trait>() -> T { ... }

    // A concrete return type is chosen by the function
    fn bar() -> impl Trait { ... }
    ```
* allows a function to return an unboxed abstract type
  * `impl Iterator`
  * compare
    ```rust
    fn foo() -> Box<dyn Fn(i32) -> i32> {
        Box::new(|x| x + 1)
    }
    ```
    with
    ```rust
    fn foo() -> impl Fn(i32) -> i32 {
        |x| x + 1
    }
    ```
* can be also used inside trait declarations as a return type of associated
  functions
  * `impl Trait` is desugared into anonymous associated type
  * the return type that appears in the implementation's function signature is
    used to determine the value of the associated type
* capturing
  * any generic parameter in the scope can be *captured* by an abstract return
    type
    * this means that a generic parameter and the abstract return type are tied
      together, that is they made some kind of contract between each other
    * once a generic parameter is captured, a concrete type, hidden behind the
      abstract return type, can use it
  * abstract return types automatically capture all in-scope generic
    parameters, including:
    * generic type parameters
    * generic `const` parameters
    * generic lifetime parameters, including higher-ranked ones
  * example:
    ```rust
    fn foo<T: Clone>(t: T) -> impl Clone {
        // 1. `T` is captured by `impl Clone` so any concrete type
        //    can now use it
        // 2. `Some(t)` implies `Option<T>` as a concrete type; `T` can be
        //    referenced (used) in `Option<T>` because `T` has been captured
        //    before
        Some(t)
    }
    ```

See [Impl trait](https://doc.rust-lang.org/reference/types/impl-trait.html),
[Generic parameters](https://doc.rust-lang.org/reference/items/generics.html),
[Paths](https://doc.rust-lang.org/reference/paths.html),
[Closure types](https://doc.rust-lang.org/reference/types/closure.html),
[Trait objects](https://doc.rust-lang.org/reference/types/trait-object.html),
[`Box`](https://doc.rust-lang.org/alloc/boxed/struct.Box.html),
[`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html),
and [`Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html) for
greater detail.

## Generics

Grammar:
```
generic_params:
    "<" ">"
    "<" (generic_param ",")* generic_param ","? ">"
generic_param:
    outer_attribute* (lifetime_param | type_param | const_param)
lifetime_param:
    lifetime_or_label (":" lifetime_bounds)?
type_param:
    identifier (":" type_param_bounds?)? ("=" type)?
const_param:
    "const" identifier ":" type
        ("=" block_expression | identifier | "-"? literal_expression)?

where_clause:
    "where" (where_clause_item ",")* where_clause_item?
where_clause_item:
    lifetime ":" lifetime_bounds
    ("for" generic_params)? type ":" type_param_bounds?
```

See [Generic parameters](https://doc.rust-lang.org/reference/items/generics.html)
for greater detail.

## Macros

Grammar:
```
macro_invocation:
    simple_path "!" delim_token_tree
macro_invocation_semi:
    simple_path "!" "(" token_tree* ")" ";"
    simple_path "!" "[" token_tree* "]" ";"
    simple_path "!" "{" token_tree* "}"

delim_token_tree:
    "(" token_tree* ")"
    "[" token_tree* "]"
    "{" token_tree* "}"
token_tree:
    token - delimiters
    delim_token_tree
```

Examples:
* [`lisp-in-rs-macros`](https://github.com/RyanWelly/lisp-in-rs-macros)
* [macro-lisp](https://github.com/JunSuzukiJapan/macro-lisp) [[doc](https://docs.rs/macro_lisp/latest/macro_lisp)] [[crate](https://crates.io/crates/macro_lisp)]

See [Macros](https://doc.rust-lang.org/reference/macros.html) for greater
detail.

### Selected Macros from the Standard Library

#### `format`

Creates a [`String`](https://doc.rust-lang.org/std/string/struct.String.html)
by the interpolation of format string literal. Example:
```rust
let (x, y) = (1, 2);

format!("x = {x}, y = {y}");     // "x = 1, y = 2"
format!("z = {z}", z = 3);       // "z = 3"
format!("Hello, {}!", "World");  // "Hello, World!"
```

> [!NOTE]
> `format!` macro takes references, i.e. `format!("{x}")` will take a reference
> of `x`. References are taken also by other macros using format string.

See [`std::format`](https://doc.rust-lang.org/std/macro.format.html) for
greater detail.

##### Format String

A format string is a string containing markers with format specification. A
marker is a string starting with `{` and ending with `}`. During interpolation,
a marker is replaced by the string representation of the corresponding value.
Additional characters between `{` and `}` specify a way of interpolating a
value.

Selected markers:
| **Marker** | **Meaning** |
| ---------- | ----------- |
| `{}` | the value's type must implement [`std::fmt::Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) trait |
| `{:?}` | the value's type must implement [`std::fmt::Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html) trait |
| `{:#?}` | `{:?}` with pretty print flag set |

See [`std::fmt`](https://doc.rust-lang.org/std/fmt/index.html) for greater
detail.

Additional references:
* [`std::fmt::Formatter`](https://doc.rust-lang.org/std/fmt/struct.Formatter.html)
* [`std::fmt::Arguments`](https://doc.rust-lang.org/std/fmt/struct.Arguments.html)
* [`std::fmt::DebugStruct`](https://doc.rust-lang.org/std/fmt/struct.DebugStruct.html)
* [`std::fmt::DebugTuple`](https://doc.rust-lang.org/std/fmt/struct.DebugTuple.html)
* [`std::fmt::DebugList`](https://doc.rust-lang.org/std/fmt/struct.DebugList.html)
* [`std::fmt::DebugSet`](https://doc.rust-lang.org/std/fmt/struct.DebugSet.html)
* [`std::fmt::DebugMap`](https://doc.rust-lang.org/std/fmt/struct.DebugMap.html)

#### `format_args`

Creates [`std::fmt::Arguments`](https://doc.rust-lang.org/std/fmt/struct.Arguments.html)
object containing precompiled format string and its arguments. Example:
```rust
let args = format_args!("{} + {} = {}", 1, 2, 3);

println!("{:?}", args);
```

See [`std::format_args`](https://doc.rust-lang.org/std/macro.format_args.html)
and [`std::fmt::Arguments`](https://doc.rust-lang.org/std/fmt/struct.Arguments.html)
for greater detail.

#### `println`

Prints interpolated format string and the new line character to the standard
output. Examples:
```rust
println!("Hello, World!");
println!("Hello, {}!", "World");
```

See [`std::println`](https://doc.rust-lang.org/std/macro.println.html) for
greater detail.

#### `eprintln`

Like `println` but prints the output to standard error output.

See [`std::eprintln`](https://doc.rust-lang.org/std/macro.eprintln.html) for
greater detail.

#### `dbg`

Prints to the standard error output and returns the value of given expression.
The value is moved. The type of the value must implement
[`std::fmt::Debug`](https://doc.rust-lang.org/std/fmt/trait.Debug.html) trait.
Examples:
```rust
let a = dbg!(2 + 5);  // Prints: [src/main.rs:2] 2 + 5 = 7

#[derive(Debug)]
struct NoCopy(u32);

let a = NoCopy(8);
let _ = dbg!(a);
let _ = dbg!(a);  // Error! (`a` was moved)
```

See [`std::dbg`](https://doc.rust-lang.org/std/macro.dbg.html) for greater
detail.

## Attributes

Grammar:
```
inner_attribute:
    "#" "!" "[" attr "]"

outer_attribute:
    "#" "[" attr "]"

attr:
    simple_path attr_input?
attr_input:
    delim_token_tree
    "=" expression
```

See [Attributes](https://doc.rust-lang.org/reference/attributes.html) for
greater detail.

### Selected Attributes Supported by Rust

#### `derive`

Allows new items to be automatically generated for data structures. Example:
```rust
// Implement `std::fmt::Debug` trait for `Point`
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

let p = Point {x: 1, y: 2};

println!("{p:#?}");  // Pretty print `p`
```

See [Derive](https://doc.rust-lang.org/reference/attributes/derive.html) for
greater detail.

#### `repr`

Specifies the layout for user-defined composite types (structs, enums, unions).
Possible representations are:
* `Rust` (default)
* `C`
* primitive
* `transparent`

Example:
```rust
// Uses default (Rust) representation
struct Foo {
    bar: isize,
    baz: u8,
}

// C representation
#[repr(C)]
struct Pixel {
    x: u32,
    y: u32,
}
```

See [Representations](https://doc.rust-lang.org/reference/type-layout.html#representations)
for greater detail.

## Rust's Module System

Grammar:
```
crate:
    utf8bom? shebang? inner_attribute* item*

module:
    "unsafe"? "mod" identifier (";" | "{" inner_attribute* item* "}")

extern_crate:
    "extern" "crate" crate_ref as_clause? ";"

crate_ref:
    identifier
    "self"
as_clause:
    "as" (identifier | "_")
```

A module system of Rust consists of these features: packages, crates, modules
and `use`, and paths.

### Packages

A package is a feature of Cargo that allows to build, test, and share crates.
It is a bundle of one or more crates, specifically:
* a package must contain at least one crate
* a package can contain as many binary crates as needed, but at most only one
  library crate

New package can be created using `cargo new` command. The layout of a package
directory:
```
foopkg/
    Cargo.toml
    /src
        lib.rs
        main.rs
        /bin
            prog1.rs
            prog2.rs
            /prog3
                main.rs
                foomod.rs
    /benches
        bench1.rs
        /bench2
            main.rs
            benchmod.rs
    /examples
        example1.rs
        /example2
            main.rs
            barmod.rs
    /tests
        test1.rs
        /test2
            main.rs
            testmod.rs
```
* `Cargo.toml` is a manifest that tells `cargo` how to build crates in a
  package
  * defaults can be override here
* the `src` directory contains source code of package crates
  * the default library crate is `lib.rs` (`cargo` produces a library with the
    same name as the package)
  * the default executable is `main.rs` (`cargo` produces an executable with
    the same name as the package)
  * the `bin` directory is a place for other executables
* the `benches` directory contains benchmarks
* the `examples` directory contains examples
* the `tests` directory contains integration tests
* if a binary executable, bench, example, or test consists of multiple source
  files (in our case `src/bin/prog3`, `benches/bench2`, `examples/example2` and
  `tests/test2`), put them into a directory:
  * `main.rs` fine determine the crate root
  * other files are considered as modules
  * the name of a directory becomes the name of the executable

### Crates

A *crate* is a smallest compilation unit, a tree of modules. There are two
types of crates:
1. A *binary crate*, which when compiles produces an executable. A binary crate
   must contain the `main` function serving as its entry point. The `main`
   function must fulfill these requirements:
   * must take no arguments
   * must not declare any trait or lifetime bounds
   * must not have any where clauses
   * its return type must implement the `Termination` trait (types from the
     standard library implementing the `Termination` trait are `()`, `!`,
     `Infallible`, `ExitCode`, `Result<T, E> where T: Termination, E: Debug`)
1. A *library crate* is a crate without `main` function. When compiled, it
   produces a library (by default statically linked) that exposes publicly
   visible items as a part of its API.

Attributes that can be applied at the crate level:
* `#![no_main]` &ndash; emit no `main` for an executable binary
* `#![crate_name = "my_crate"]` &ndash; set the name of a crate to `my_crate`
  * hyphens are disallowed in crate names
    * if the crate name is resolved from the package name, Cargo will replace
      all hyphens with underscores
* `#![no_std]`
  * prevents `std` from being added to the extern prelude
    * note that this does not prevent `std` from being linked in using
      `extern crate std;`
  * affects which module is used to make up the standard library prelude (see
    [Preludes](#preludes))
  * injects the `core` crate into the crate root instead of `std`
  * pulls in all macros exported from `core` in the `macro_use` prelude

A source file from which the Rust compiler starts and makes up the root module
of the crate is called the *crate root*.
* the contents of the source file forms a module named `crate` which sits at
  the root of the crate's module structure, known as the module tree

The root module of a crate is the top-level of the crate's module tree.
* the root module is anonymous (from the point of view of paths within the
  module) and it is accessible via `crate` path

Any item within a crate has a canonical module path denoting its location
within the crate's module tree.

Handling the standard library:
* automatically included in the crate root module
* the `std` crate is added to the root
* implicit `macro_use` attribute pulls in all macros exported in `std` into the
  `macro_use` prelude
* `core` and `std` are added to the extern prelude

#### Extern Crates

An extern crate declaration specifies a dependency on an external crate:
* the external crate is bound into the declaring scope as the identifier
  provided in the declaration
* if the declaration appears in the crate root, the crate name is also added to
  the extern prelude so it will be automatically available in scope in all
  modules
* the `as` clause can be used to bind the imported crate to a different name
* the `self` crate may be imported
  * a binding to the current crate is created
  * `as` clause is mandatory in this case
* `extern crate foo as _;` specifies a dependency on an external crate without
  binding its name in scope
  * useful for crates that only need to be linked
* `no_link` attribute prevents a crate to be linked
  * useful to load a crate to only access its macros

During compile time and runtime linkage:
1. If the `extern crate` declaration has a `crate_name` attribute, let NAME be
   the value of this attribute. Otherwise, let NAME be from
   `extern crate NAME`.
1. From the compiler's library path and NAME resolve SONAME.
1. At runtime, pass a runtime linkage requirement SONAME have to the linker for
   loading.

Example:
```rust
extern crate pcre;
extern crate std;             // Same as `extern crate std as std;`
extern crate std as ruststd;  // Linking to `std` under `ruststd`
```

### Modules

A module is a container of zero or more items.
* `mod foo { ... }` introduces a new named module, `foo`, into the tree of
  modules making up a crate.
* Modules can nest arbitrarily.
* Modules and types share the same name space.
* In `unsafe mod foo { ... }`, `unsafe` is rejected at a semantic level (that
  is, it has use only when feed into a macro).

Every source file is a module, but not every module needs its own source file.

A module without body, i.e. `mod foo;` statement, is loaded from an external
file.
* The path to the file mirrors the logical module path, unless the module does
  have a `path` attribute.
* Ancestor module path components are directories.
* The module's contents are in a file with the name of the module plus the
  `.rs` extension.
  * If the file name containing the module's contents is `mod.rs`, the module
    file name is the name of the directory containing this `mod.rs` file.
  * For `crate::foo`, it is not allowed to have both `foo.rs` and `foo/mod.rs`.
  * Since `rustc` 1.30, using `mod.rs` files is considered obsolete.
* If a `path` attribute is given, it specifies the location of an external file
  with the module's content to be loaded. There are three ways of handling
  `path` attributes:
  1. A `path` attribute is not inside inline module block, e.g.
     ```rust
     // File `src/a/b.rs` (1) or `src/a/mod.rs` (2):
     #[path = "foo.rs"]
     mod c;
     // The path to the `c` module is:
     //   - `crate::a::b::c` in case of (1)
     //   - `crate::a::c` in case of (2)
     ```
     * the file path is relative to the directory the source file is located,
       e.g. the external file with the `c` module's content is located at
       `src/a/foo.rs`
  1. A `path` attribute is inside inline module block and the source file where
     the `path` attribute is located is the root module (like `lib.rs` or
     `main.rs`) or `mod.rs`, e.g.
     ```rust
     // File `src/lib.rs` (1) or `src/a/mod.rs` (2):
     mod inline {
         #[path = "other.rs"]
         mod inner;
     }
     // The `other.rs` file will be searched at:
     //   - `src/inline/other.rs` in case of (1)
     //       * the path to the `inner` module is `crate::inline::inner`
     //   - `src/a/inline/other.rs` in case of (2)
     //       * the path to the `inner` module is `crate::a::inline::inner`
     ```
     * the file path is relative to the directory of root module file or
       `mod.rs` file including the inline module components as directories
  1. A `path` attribute is inside inline module block and the source file where
     the `path` attribute is located is neither the root module nor `mod.rs`,
     e.g.
     ```rust
     // File `src/a/b.rs`:
     mod inline {
         #[path = "other.rs"]
         mod inner;
     }
     // The `other.rs` file will be searched at `src/a/b/inline/other.rs`.
     // The path to the `inner` module is `crate::a::b::inline::inner`.
     ```
     * the file path is relative to the directory of the source file with the
       `path` attribute, including the directory with the same name as the
       module that corresponds to the source file and the inline module
       components as directories
     * rules can be combined:
       ```rust
       // File `src/main.rs`:
       mod a;

       fn main() {
           crate::a::b::thread::thread_local::join();
       }

       // File `src/a.rs`:
       pub mod b;

       // File `src/a/b.rs`:
       #[path = "threads"]
       pub mod thread {
           #[path = "tls.rs"]
           pub mod thread_local;
       }
       // The `tls.rs` file will be searched at `src/a/threads/tls.rs`.
       // The path to the `thread_local` module is `crate::a::b::thread::thread_local`.

       // File `src/a/threads/tls.rs`:
       pub fn join() {}
       ```

A module can have attributes.
* attributes in a source file applies to the containing module
* attributes applied to the anonymous root module apply also to the crate as a
  whole
* the built-in attributes that have meaning on modules: `cfg`, `deprecated`,
  `doc`, `allow`, `warn`, `deny`, `forbid`, `path`, and `no_implicit_prelude`

Example:
```rust
// File `src/lib.rs`:
//   - this is the crate root
//   - the path accessing this module is `crate` (this module is the root
//     module)
// This module is loaded from the external file, `src/util.rs`. The effect is
// the same as `mod util { /* contents of src/util.rs */ }`:
//   - the path to the `util` module is `crate::util`
mod util;
// Like `util` module. The path to the `lexer` module is `crate::lexer`:
mod lexer;

// File `src/util.rs`:
//   - the path accessing this module is `crate::util`
//   - the path to the just loaded `config` module is `crate::util::config`
mod config;

// File `src/util/config.rs`:
//   - the path accessing this module is `crate::util::config`
struct Config {
    pub (crate) vmem_limit: usize,
    pub (crate) stack_limit: usize,
    pub (crate) nfiles_limit: usize,
}

// File `src/lexer/mod.rs`:
//   - the path accessing this module is `crate::lexer`
//   - the path to the `token` module is `crate::lexer::token`
mod token;

//   - the path to the `scan` function is `crate::lexer::scan`
pub fun scan() -> token::Token {
    token::Token(42)
}

// File `src/lexer/token.rs`:
//   - the path accessing this module is `crate::lexer::token`
//   - the path to the `Token` struct is `crate::lexer::token::Token`
struct Token(u8);
```

See [Package Layout](https://doc.rust-lang.org/cargo/guide/project-layout.html),
[The Manifest Format](https://doc.rust-lang.org/cargo/reference/manifest.html),
[Cargo Targets](https://doc.rust-lang.org/cargo/reference/cargo-targets.html),
[Crates and source files](https://doc.rust-lang.org/reference/crates-and-source-files.html),
[Trait and lifetime bounds](https://doc.rust-lang.org/reference/trait-bounds.html),
[Where clauses](https://doc.rust-lang.org/reference/items/generics.html#where-clauses),
[Trait std::process::Termination](https://doc.rust-lang.org/std/process/trait.Termination.html),
[Never type](https://doc.rust-lang.org/reference/types/never.html),
[Enum std::convert::Infallible](https://doc.rust-lang.org/std/convert/enum.Infallible.html),
[Struct std::process::ExitCode](https://doc.rust-lang.org/std/process/struct.ExitCode.html),
[Modules](https://doc.rust-lang.org/reference/items/modules.html),
[Conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html),
[Diagnostic attributes](https://doc.rust-lang.org/reference/attributes/diagnostics.html),
[The `#[doc]` attribute](https://doc.rust-lang.org/rustdoc/write-documentation/the-doc-attribute.html),
[Preludes](https://doc.rust-lang.org/reference/names/preludes.html),
[Paths](https://doc.rust-lang.org/reference/paths.html),
[Extern crate declarations](https://doc.rust-lang.org/reference/items/extern-crates.html),
[Macros By Example](https://doc.rust-lang.org/reference/macros-by-example.html),
and [Attributes](https://doc.rust-lang.org/reference/attributes.html) for
greater detail.

### Preludes

A *prelude* is a collection of names that are automatically brought into scope
of every module in a crate.
* these prelude names are not part of the module itself
  * they are implicitly queried during name resolution
  * e.g. `Box` is valid but `self::Box` is not because `Box` is not a member of
    the current module
* the `no_implicit_prelude` attribute
  * applicable at the crate level (root module) or on a module
  * indicates that it should not automatically bring the standard library
    prelude, extern prelude, `macro_use` prelude, or tool prelude into scope
    for that module or any of its descendants

There are several kinds of preludes:
* **Standard library prelude**
  * each crate has it
  * consists of the names from a single standard library module
    * if `no_std` attribute is applied, this module is
      `core::prelude::rust_EDITION`
    * otherwise, this module is `std::prelude::rust_EDITION`
* **Extern prelude**
  * consists of these crates:
    * external crates imported with `extern crate` in the root module
      * if `extern crate foo as bar` is used, the external crate `foo` is added
        to the extern prelude under the name `bar`
    * external crates provided to the compiler (`rustc --extern`)
    * the `core` crate
    * the `std` crate as long as the `no_std` attribute is not specified in the
      crate root
  * Cargo does bring in `proc_macro` to the extern prelude for proc-macro
    crates only
* **Language prelude**
  * is always in scope
  * includes names of types and attributes that are built-in to the language
* **`macro_use` prelude**
  * macros from external crates, imported by the `macro_use` attribute applied
    to an `extern crate`, are included into the `macro_use` prelude
* **Tool prelude**
  * includes tool names for external tools in the type name space
  * in the tool prelude, each tool resides in its own name space
  * when a tool attribute is recognized by the compiler (i.e. when a tool is
    found in the tool prelude), the compiler accepts it without any warning
    * `rustc` currently recognizes the tools `rustfmt` and `clippy`
  * when a tool attribute is recognized by a tool, the tool is responsible for
    further processing and interpretation of the attribute

See [Preludes](https://doc.rust-lang.org/reference/names/preludes.html),
[Extern crate declarations](https://doc.rust-lang.org/reference/items/extern-crates.html),
[Use declarations](https://doc.rust-lang.org/reference/items/use-declarations.html),
[Macros By Example](https://doc.rust-lang.org/reference/macros-by-example.html),
[Namespaces](https://doc.rust-lang.org/reference/names/namespaces.html),
and [Attributes](https://doc.rust-lang.org/reference/attributes.html) for
greater detail.

### Visibility

Grammar:
```
visibility:
    "pub"
    "pub" "(" "crate" ")"
    "pub" "(" "self" ")"
    "pub" "(" "super" ")"
    "pub" "(" "in" simple_path ")"
```
* everything in Rust is private by default except
  * associated item in a `pub` trait
  * enum variants in a `pub` enum
  * items marked with `pub`
* an item is accessible in two cases:
  1. a public (`pub`) item can be accessed externally from some module `m` only
     if all the item's ancestors from `m` can also be accessed externally
  1. a private item can be accessed by the current module and its descendants
* availability of public items can be further restricted:
  * `pub(crate)` makes an item visible within the current crate
  * `pub(self)` is equivalent to `pub(in self)` or not using `pub` at all
  * `pub(super)` is equivalent to `pub(in super)`
  * `pub(in path)` makes an item visible within the provided `path`
    * `path` must be an ancestor module of the item whose visibility is being
      declared
    * `pub(in self)` makes an item visible to the current module
    * `pub(in super)` makes an item visible to the parent module
* `pub` together with `use` can be used for re-exporting items
  * `use` brings items to the current scope as usual
  * `pub` makes them public

Examples:
* accessibility of items demonstration:
  ```rust
  // `foo` is private, so no external crate can access it (rule #1).
  // Any module in this crate can access `foo`'s public interface since `foo`
  // lays in the root module of this crate (rule #2).
  mod foo {
      // Can be used by anything in the current crate (rule #1).
      pub fn f() {}

      // Can be accessed only by this module and its descendants (rule #2).
      fn g() {}
  }

  // Public to the root module, available to external crates (rule #1).
  pub fn h() {}

  // Public to the root module, available to external crates (rule #1).
  pub mod bar {
      // This is legal since `bar` is a descendant of the root module (rule #2).
      use crate::foo;

      // Available to external crates (rule #1).
      pub fn x() {
          // This is legal (rule #2).
          foo::f();
      }

      // Available only to this module and its descendants (rule #2).
      fn y() {}

      #[cfg(test)]
      mod test {
          #[test]
          fn test_y() {
              // This is legal since this module is a descendant of the module
              // `bar` (rule #2).
              super::y();
          }
      }
  }
  ```
* accessibility with restrictions:
  ```rust
  pub mod a {
      pub mod b {
          // Visible within `a`.
          pub (in crate::a) fn fa() {}

          // Visible to entire crate.
          pub (crate) fn fb() {}

          // Visible within `a`.
          pub (super) fn fc() {
              // Visible since we are in the same module.
              fd();
          }

          // Visible only within `b` (same as leaving `fd` private).
          pub (self) fn fd() {}
      }

      pub fn ga() {
          b::fa();
          b::fb();
          b::fc();
          //b::fd();  // Error
      }
  }

  fn ha() {
      // Still visible (we are in the same crate).
      a::b::fb();
      //a::b::fc();  // Error (we are outside of `a`)
      //a::b::fa();  // Error (we are outside of `a`)
      a::ga();
  }

  fn main() { ha() }
  ```
* re-importing/re-exporting names into the current scope:
  ```rust
  // From the standard library: brings `Option`, `None`, and `Some` to the
  // current scope and makes them publicly visible
  pub use crate::option::Option;
  pub use crate::option::Option::None;
  pub use crate::option::Option::Some;
  ```
* another example of re-exporting:
  ```rust
  pub use self::a::b;

  mod a {
      pub mod b {
          pub fn f() {}
      }
  }

  b::f();       // Valid (`b` is public in this scope, `f` is public in `b`)
  //a::b::f();  // Invalid (`a` is private)
  ```

See [Visibility and Privacy](https://doc.rust-lang.org/reference/visibility-and-privacy.html)
and [Use declarations](https://doc.rust-lang.org/reference/items/use-declarations.html)
for greater detail.

### Paths

A path refers to:
* item or variable if it has only one component
* item if it has more than one component

Path qualifiers:
* `::`
  * paths starting with `::` are considered to be *global paths*
  * segments of the path start being resolved from a place which differs based
    on edition
    * in the 2015 Edition, identifiers resolve from the crate root, i.e.
      `::foo` in the 2015 Edition is the same as `crate::foo` in the 2018 and
      newer Edition
    * in the 2018 and newer Edition, identifiers resolve from crates in the
      extern prelude, i.e. they must be followed by the name of a crate, e.g.
      `::core` resolves to the `core` crate which is always added to the extern
      prelude
      * `::` is necessary if a name from to root module collide with the name
        from the extern prelude, e.g.
        ```rust
        //use std::fs;                // Error, ambiguity
        use ::std::fs;                // Imports `fs` from the standard `std` crate
        use self::std::fs as std_fs;  // Imports `fs` from the `std` module below

        mod std {
            pub mod fs {}
        }
        ```
* `self`
  * resolves to the current module
  * a single `self` in a method body resolves to the method's `self` parameter
* `Self`
  * refers to the implementing type within traits and implementations
* `super`
  * resolves to the parent module
* `crate`
  * refers to the root module of the current crate
* `$crate`
  * allowed only inside macro transcribers
  * refers to the root module of the crate where the macro is defined

Canonical paths:
* only items defined in a module or implementation have a canonical path
* a canonical path reflects the location of the item relatively to the root
  module of its crate, e.g.
  ```rust
  // File `src/lib.rs`:
  mod foo {
      // Canonical path to this struct is `crate::foo::Foo`
      pub struct Foo;
  }
  ```
  * it is meaningful only within a given crate (there is no global namespace
    across crates)
* a canonical path consists of a *path prefix* and an item appended to it
  * for modules, the path prefix is the canonical path to that module, e.g.
    ```rust
    // File `src/lib.rs`:
    mod foo {        // `crate::foo` (the canonical path to the module `foo`)
        struct Bar;  // `crate::foo::Bar` (the canonical path to the `struct Bar`)
    }
    ```
  * for bare implementations, the path prefix has the form `<P>`, where `P` is
    the canonical path of the item being implemented, e.g.
    ```rust
    // File `src/lib.rs`:
    mod foo {
        struct Bar;

        impl Bar {
            // The canonical path to the method `f` implemented here is
            // `<crate::foo::Bar>::f`.
            fn f(&self) {}
        }
    }
    ```
  * for trait implementations, the path prefix has the form `<P as T>`, where
    `P` is the canonical path of the item being implemented and `T` is the
    canonical path to the trait, e.g.
    ```rust
    // File `src/lib.rs`:
    mod a {
        struct S;

        trait T {
            fn f(&self);
        }

        impl T for S {
            // The canonical path to the method `f` implemented here is
            // `<crate::a::S as crate::a::T>::f`.
            fn f(&self) {}
        }

        impl S {
            fn g(&self) {}
        }
    }
    ```
* items which do not have canonical paths:
  * implementations
  * use declarations
  * items defined in block expressions
  * items defined in a module that does not have a canonical path
  * associated items defined in an implementation that refers to an item
    without a canonical path

#### Simple Paths

Grammar:
```
simple_path:
    "::"? simple_path_segment ("::" simple_path_segment)*
simple_path_segment:
    identifier | "super" | "self" | "crate" | "$crate"
```
* used in visibility markers, attributes, macros and, `use` items

#### Paths in Expressions

Grammar:
```
path_in_expression:
    "::"? path_expr_segment ("::" path_expr_segment)*
path_expr_segment:
    path_ident_segment ("::" generic_args)?
path_ident_segment:
    identifier | "super" | "self" | "Self" | "crate" | "$crate"
generic_args:
    "<" ((generic_arg ",")* generic_arg ","?)? ">"
generic_arg:
    lifetime
    type
    block_expression
    "-"? literal_expression
    simple_path_segment
    identifier "=" type
```
* allow for paths with generic arguments to be specified
* used in expressions and patterns
* *turbofish* (`::<`) syntax:
  * `Vec<u8>::with_capacity(1024)` &ndash; wrong (ambiguity with `<`)
  * `Vec::<u8>::with_capacity(1024)` &ndash; correct
* the order of generic arguments is restricted to:
  1. lifetime arguments, then
  1. type arguments, then
  1. const arguments, then
  1. equality constraints

#### Qualified Paths

Grammar:
```
qualified_path_in_expression:
    qualified_path_type ("::" path_expr_segment)+

qualified_path_type:
    "<" type ("as" type_path)? ">"

qualified_path_in_type:
    qualified_path_type ("::" type_path_segment)+
```
* allow paths for trait implementations to be unambiguous
* allow canonical paths to be specified
* example:
  ```rust
  struct S;

  // Implementation of `struct S`:
  impl S {
      fn f() {}
  }

  trait T1 {
      fn f() {}
  }

  // Implementation of `trait T1` for `struct S`:
  impl T1 for S {}

  trait T2 {
      fn f() {}
  }

  // Implementation of `trait T2` for `struct S`:
  impl T2 for S {}

  // Which `f` is called? `S` implements both `T1` and `T2` so we use type cast
  // to resolve ambiguity:
  S::f();          // `S::f` is called
  <S as T1>::f();  // `T1::f` is called
  <S as T2>::f();  // `T2::f` is called
  ```

#### Type Paths

Grammar:
```
type_path:
    "::"? type_path_segment ("::" type_path_segment)*
type_path_segment:
    path_ident_segment ("::"? (generic_args | type_path_fn))?
type_path_fn:
    "(" (type ("," type)* ","?)? ")" ("->" type)?
```
* used within type definitions, trait bounds, type parameter bounds, and
  qualified paths
* turbofish notation (`::<`) is not required here as there is no danger of
  ambiguity like in expressions

See [Paths](https://doc.rust-lang.org/reference/paths.html),
[Visibility and Privacy](https://doc.rust-lang.org/reference/visibility-and-privacy.html),
[Attributes](https://doc.rust-lang.org/reference/attributes.html),
[Macros By Example](https://doc.rust-lang.org/reference/macros-by-example.html),
[Use declarations](https://doc.rust-lang.org/reference/items/use-declarations.html),
[Expressions](https://doc.rust-lang.org/reference/expressions.html),
[Patterns](https://doc.rust-lang.org/reference/patterns.html),
[Traits](https://doc.rust-lang.org/reference/items/traits.html),
[Implementations](https://doc.rust-lang.org/reference/items/implementations.html),
and [Preludes](https://doc.rust-lang.org/reference/names/preludes.html) for
greater detail.

## Libraries (Crates) and Tools

Pinned: [[Lib.rs](https://lib.rs/)]
* [`aho-corasick` - fast multiple substring searching](https://crates.io/crates/aho-corasick) [[doc](https://docs.rs/aho-corasick/latest/aho_corasick)] [[repo](https://github.com/BurntSushi/aho-corasick)]
* [`anyhow` - flexible concrete error type built on `std::error::Error`](https://crates.io/crates/anyhow) [[doc](https://docs.rs/anyhow/latest/anyhow)] [[repo](https://github.com/dtolnay/anyhow)]
* [`ariadne` - a fancy diagnostics and reporting](https://crates.io/crates/ariadne) [[doc](https://docs.rs/ariadne/latest/ariadne)] [[repo](https://github.com/zesterer/ariadne)]
* [`atty` - is it a tty?](https://crates.io/crates/atty) [[doc](https://docs.rs/atty/latest/atty)] [[repo](https://github.com/softprops/atty)]
* [`backon` - make retry like a built-in feature provided by Rust](https://crates.io/crates/backon) [[doc](https://docs.rs/backon/latest/backon)] [[repo](https://github.com/Xuanwo/backon)]
* [`bat` - a `cat(1)` clone with wings](https://crates.io/crates/bat) [[doc](https://docs.rs/bat/latest/bat)] [[repo](https://github.com/sharkdp/bat)]
* [`bzip2-rs` - Rust bzip2 decompressor](https://crates.io/crates/bzip2-rs) [[doc](https://docs.rs/bzip2-rs/latest/bzip2_rs)] [[repo](https://github.com/paolobarbolini/bzip2-rs)]
* [`cargo` - package manager for Rust](https://crates.io/crates/cargo) [[doc](https://docs.rs/cargo/latest/cargo)] [[repo](https://github.com/rust-lang/cargo)]
* [`cargo-binutils` - proxy for LLVM tools](https://crates.io/crates/cargo-binutils) [[repo](https://github.com/rust-embedded/cargo-binutils)]
* [`chrono` - date and time library](https://crates.io/crates/chrono) [[doc](https://docs.rs/chrono/latest/chrono)] [[repo](https://github.com/chronotope/chrono)]
* [`chumsky` - a parser library for humans with powerful error recovery](https://crates.io/crates/chumsky) [[doc](https://docs.rs/chumsky/latest/chumsky)] [[repo](https://github.com/zesterer/chumsky)]
* [`clap` - command line argument parser for Rust](https://crates.io/crates/clap) [[doc](https://docs.rs/clap/latest/clap)] [[repo](https://github.com/clap-rs/clap)]
* [`colored` - coloring terminal](https://crates.io/crates/colored) [[doc](https://docs.rs/colored/latest/colored)] [[repo](https://github.com/colored-rs/colored)]
* [`core` - the Rust core (i.e. dependency free) library](https://doc.rust-lang.org/core/index.html)
  * [`core::ptr` - manually manage memory through raw pointers](https://doc.rust-lang.org/core/ptr/index.html)
    * [`core::ptr::addr_of` - create a `const` raw pointer to a place, without creating an intermediate reference](https://doc.rust-lang.org/core/ptr/macro.addr_of.html)
    * [`core::ptr::addr_of_mut` - create a `mut` raw pointer to a place, without creating an intermediate reference](https://doc.rust-lang.org/core/ptr/macro.addr_of_mut.html)
* [`crates-index` - interacting with the `crates.io` index](https://crates.io/crates/crates-index) [[doc](https://docs.rs/crates-index/latest/crates_index)] [[repo](https://github.com/frewsxcv/rust-crates-index)]
* [`crossbeam` - tools for concurrent programming](https://crates.io/crates/crossbeam) [[doc](https://docs.rs/crossbeam/latest/crossbeam)] [[repo](https://github.com/crossbeam-rs/crossbeam)]
* [`ctor` - `__attribute__((constructor))` for Rust](https://crates.io/crates/ctor) [[doc](https://docs.rs/ctor/latest/ctor)] [[repo](https://github.com/mmastrac/rust-ctor)]
* [`cve-rs` - blazingly fast memory vulnerabilities](https://crates.io/crates/cve-rs) [[doc](https://docs.rs/cve-rs/latest/cve_rs)] [[repo](https://github.com/Speykious/cve-rs)]
* [`deepsize` - measuring the total size of object on the stack and heap](https://crates.io/crates/deepsize) [[doc](https://docs.rs/deepsize/latest/deepsize)] [[repo](https://github.com/Aeledfyr/deepsize)]
* [Development tools :: Testing](https://crates.io/categories/development-tools::testing)
* [`dotenvy` - supply environment variables, load them from `.env`](https://crates.io/crates/dotenvy) [[doc](https://docs.rs/dotenvy/latest/dotenvy)] [[repo](https://github.com/allan2/dotenvy)]
* [`duct` - a library for running child processes](https://crates.io/crates/duct) [[doc](https://docs.rs/duct/latest/duct)] [[repo](https://github.com/oconnor663/duct.rs)]
* [`emit` - structured diagnostic](https://crates.io/crates/emit) [[doc](https://docs.rs/emit/latest/emit)] [[repo](https://github.com/emit-rs/emit)]
* [`emit_term` - emit diagnostic events to the console](https://crates.io/crates/emit_term) [[doc](https://docs.rs/emit_term/latest/emit_term/)] [[repo](https://github.com/emit-rs/emit)]
* [`enumset` - a library for creating compact sets of enums](https://crates.io/crates/enumset) [[doc](https://docs.rs/enumset/latest/enumset)] [[repo](https://github.com/Lymia/enumset)]
* [`env_logger` - a simple logger that can be configured via environment variables](https://crates.io/crates/env_logger) [[doc](https://docs.rs/env_logger/latest/env_logger)] [[repo](https://github.com/rust-cli/env_logger)]
  * `RUST_LOG=[target][=][level][,...]` controls logging, examples (considering
    a Rust application `log_demo`):
    * `RUST_LOG=log_demo` turns on all logging for `log_demo`
    * `RUST_LOG=none` turns off all logging (`none` is unknown target)
    * `RUST_LOG=OFF` turns off all logging (`off` is pseudo level made for this
      purpose)
    * `RUST_LOG=info` turns on all info logging
    * `RUST_LOG=log_demo=debug` turns on all debug logging for `log_demo`
    * `RUST_LOG=off,log_demo::foo=info` turn off all logging but keep all info
      logging for `log_demo::foo`
    * `RUST_LOG=info,log_demo::foo=off` turn on all info logging but turn off
      all logging for `log_demo::foo`
* [`eyre` - flexible concrete Error Reporting type built on `std::error::Error` with customizable Reports](https://crates.io/crates/eyre) [[doc](https://docs.rs/eyre/latest/eyre)] [[repo](https://github.com/eyre-rs/eyre)]
* [`git2` - bindings to `libgit2` C library](https://crates.io/crates/git2) [[doc](https://docs.rs/git2/latest/git2)] [[repo](https://github.com/rust-lang/git2-rs)]
* [`glob` - matching file paths against Unix shell style patterns](https://crates.io/crates/glob) [[doc](https://docs.rs/glob/latest/glob)] [[repo](https://github.com/rust-lang/glob)]
* [`globset` - cross platform single glob and glob set matching](https://crates.io/crates/globset) [[doc](https://docs.rs/globset/latest/globset)] [[repo](https://github.com/BurntSushi/ripgrep)]
* [`grcov` - Rust tool to collect and aggregate code coverage data for multiple source files](https://crates.io/crates/grcov) [[doc](https://docs.rs/grcov/latest/grcov)] [[repo](https://github.com/mozilla/grcov)]
* [`hyperfine` - a command-line benchmarking tool](https://crates.io/crates/hyperfine) [[doc](https://docs.rs/crate/hyperfine/latest)] [[repo](https://github.com/sharkdp/hyperfine)]
* [`image` - an image processing library](https://crates.io/crates/image) [[doc](https://docs.rs/image/latest/image)] [[repo](https://github.com/image-rs/image)]
* [`jaro_winkler` - Jaro-Winkler string distance comparison](https://crates.io/crates/jaro_winkler) [[doc](https://docs.rs/jaro_winkler/latest/jaro_winkler)] [[repo](https://docs.rs/jaro_winkler/latest/jaro_winkler/)]
* [`jsn` - queryable, streaming, JSON pull parser](https://crates.io/crates/jsn) [[doc](https://docs.rs/jsn/latest/jsn)] [[repo](https://git.sr.ht/~eanyanwu/jsn)]
* [`just` - a `make`-like tool](https://crates.io/crates/just) [[home](https://just.systems/)] [[doc](https://docs.rs/just/latest/just/)] [[repo](https://github.com/casey/just)]
* [`kellnr` - the registry for Rust crates](https://kellnr.io/) [[repo](https://github.com/kellnr/kellnr)]
* [`ktra` - little cargo registry](https://crates.io/crates/ktra) [[book](https://book.ktra.dev/)] [[doc](https://docs.rs/crate/ktra/latest)] [[repo](https://github.com/moriturus/ktra)]
* [`lazy_static` - a macro for declaring lazily evaluated statics](https://crates.io/crates/lazy_static) [[doc](https://docs.rs/lazy_static/latest/lazy_static)] [[repo](https://github.com/rust-lang-nursery/lazy-static.rs)]
* [`libc` - raw FFI bindings to platforms' system libraries](https://crates.io/crates/libc) [[doc](https://docs.rs/libc/latest/libc)] [[repo](https://github.com/rust-lang/libc)]
* [`log` - a lightweight logging facade for Rust](https://crates.io/crates/log) [[doc](https://docs.rs/log/latest/log)] [[repo](https://github.com/rust-lang/log)]
* [`memchr` - heavily optimized routines for string search primitives](https://crates.io/crates/memchr) [[doc](https://docs.rs/memchr/latest/memchr)] [[repo](https://github.com/BurntSushi/memchr)]
* [`nom` - a byte-oriented, zero-copy, parser combinators library](https://crates.io/crates/nom) [[doc](https://docs.rs/nom/latest/nom)] [[repo](https://github.com/rust-bakery/nom)]
* [`nu` - a new type of shell](https://crates.io/crates/nu) [[home](https://www.nushell.sh/)] [[book](https://www.nushell.sh/book/)] [[doc](https://docs.rs/crate/nu/latest)] [[repo](https://github.com/nushell/nushell)]
* [`num` - numeric types and traits (bigint, complex, rational and more)](https://crates.io/crates/num) [[doc](https://docs.rs/num/latest/num)] [[repo](https://github.com/rust-num/num)]
* [`num_cpus` - get the number of CPUs on a machine](https://crates.io/crates/num_cpus) [[doc](https://docs.rs/num_cpus/latest/num_cpus)] [[repo](https://github.com/seanmonstar/num_cpus)]
* [`openssl` - bindings to OpenSSL](https://crates.io/crates/openssl) [[doc](https://docs.rs/openssl/latest/openssl)] [[repo](https://github.com/sfackler/rust-openssl)]
* [`parking_lot` - more compact and efficient implementations of the standard synchronization primitives](https://crates.io/crates/parking_lot) [[doc](https://docs.rs/parking_lot/latest/parking_lot)] [[repo](https://github.com/Amanieu/parking_lot)]
* [`peak_alloc` - an allocator to keep track of (the max) allocated memory](https://crates.io/crates/peak_alloc) [[doc](https://docs.rs/peak_alloc/latest/peak_alloc)] [[repo](https://github.com/xgillard/peak_alloc)]
* [`proc-macro2` - a substitute implementation of `proc_macro` API](https://crates.io/crates/proc-macro2) [[doc]](https://docs.rs/proc-macro2/latest/proc_macro2) [[repo](https://github.com/dtolnay/proc-macro2)]
* [`quote` - quasi-quoting](https://crates.io/crates/quote) [[doc](https://docs.rs/quote/latest/quote)] [[repo](https://github.com/dtolnay/quote)]
* [`rand` - random number generators](https://crates.io/crates/rand) [[doc](https://docs.rs/rand/latest/rand)] [[repo](https://github.com/rust-random/rand)]
* [`ratatui` - cooking up terminal user interfaces](https://crates.io/crates/ratatui) [[home](https://ratatui.rs/)] [[doc](https://docs.rs/ratatui/latest/ratatui)] [[repo](https://github.com/ratatui/ratatui)]
* [`rayon` - simple work-stealing parallelism](https://crates.io/crates/rayon) [[doc](https://docs.rs/rayon/latest/rayon)] [[repo](https://github.com/rayon-rs/rayon)]
* [`regex` - regular expressions](https://crates.io/crates/regex) [[doc](https://docs.rs/regex/latest/regex)] [[repo](https://github.com/rust-lang/regex)]
* [`reqwest` - higher level HTTP client library](https://crates.io/crates/reqwest) [[doc](https://docs.rs/reqwest/latest/reqwest)] [[repo](https://github.com/seanmonstar/reqwest)]
* [`rhai` - embedded scripting for Rust](https://crates.io/crates/rhai) [[home](https://rhai.rs/)] [[book](https://rhai.rs/book/)] [[doc](https://docs.rs/rhai/latest/rhai)] [[repo](https://github.com/rhaiscript/rhai)]
* [`rust-lzma` - simple interface for LZMA compression and decompression](https://crates.io/crates/rust-lzma) [[doc](https://docs.rs/rust-lzma/latest/lzma)] [[repo](https://github.com/fpgaminer/rust-lzma)]
* [`rust-script` - run Rust "scripts"](https://crates.io/crates/rust-script) [[home](https://rust-script.org/)] [[doc](https://docs.rs/crate/rust-script/latest)] [[repo](https://github.com/fornwall/rust-script)]
* [`rustc-demangle` - Rust compiler symbol demangling](https://crates.io/crates/rustc-demangle) [[doc](https://docs.rs/rustc-demangle/latest/rustc_demangle)] [[repo](https://github.com/rust-lang/rustc-demangle)]
* [`rustc_version` - a library for querying the version of a `rustc` compiler](https://crates.io/crates/rustc_version) [[doc](https://docs.rs/rustc_version/latest/rustc_version)] [[repo](https://github.com/djc/rustc-version-rs)]
* [`serde` - a generic serialization/deserialization framework](https://crates.io/crates/serde) [[home](https://serde.rs/)] [[doc](https://docs.rs/serde/latest/serde)] [[repo](https://github.com/serde-rs/serde)]
* [`serial_test` - allows for the creation of serialised Rust tests](https://crates.io/crates/serial_test) [[doc](https://docs.rs/serial_test/latest/serial_test)] [[repo](https://github.com/palfrey/serial_test/)]
* [`stacker` - a stack growth library](https://crates.io/crates/stacker) [[doc](https://docs.rs/stacker/latest/stacker)] [[repo](https://github.com/rust-lang/stacker)]
* [`state` - a library for safe and effortless global and thread-local state management](https://crates.io/crates/state) [[doc](https://docs.rs/state/latest/state)] [[repo](https://github.com/SergioBenitez/state/)]
* [`std` - the Rust standard library](https://doc.rust-lang.org/std/index.html)
  * [`std::alloc` - memory allocation APIs](https://doc.rust-lang.org/std/alloc/index.html)
    * [`std::alloc::Layout` - layout of a block of memory](https://doc.rust-lang.org/std/alloc/struct.Layout.html)
  * [`std::borrow` - a module for working with borrowed data](https://doc.rust-lang.org/std/borrow/index.html)
    * [`std::borrow::Cow` - a clone-on-write smart pointer](https://doc.rust-lang.org/std/borrow/enum.Cow.html)
  * [`std::boxed` - the `Box<T>` type for heap allocation](https://doc.rust-lang.org/std/boxed/index.html)
    * [`std::boxed::Box` - a pointer type that uniquely owns a heap allocation of type `T`](https://doc.rust-lang.org/std/boxed/struct.Box.html)
  * [`std::cell` - shareable mutable containers](https://doc.rust-lang.org/stable/std/cell/index.html)
    * [`std::cell::UnsafeCell` - the core primitive for interior mutability in Rust](https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html)
  * [`std::collections` - collection types](https://doc.rust-lang.org/std/collections/index.html)
    * [`std::collections::HashSet` - a hash set](https://doc.rust-lang.org/std/collections/struct.HashSet.html)
  * [`std::convert` - traits for conversions between types](https://doc.rust-lang.org/std/convert/index.html)
    * [`std::convert::AsRef` - used to do a cheap reference-to-reference conversion](https://doc.rust-lang.org/std/convert/trait.AsRef.html)
    * [`std::convert::From` - used to do value-to-value conversions while consuming the input value](https://doc.rust-lang.org/std/convert/trait.From.html)
    * [`std::convert::Into` - a value-to-value conversion that consumes the input value](https://doc.rust-lang.org/std/convert/trait.Into.html)
    * [`std::convert::TryFrom` - simple and safe type conversions that may fail in a controlled way](https://doc.rust-lang.org/std/convert/trait.TryFrom.html)
  * [`std::default` - the `Default` trait for types with a default value](https://doc.rust-lang.org/std/default/index.html)
    * [`std::default::Default` - a trait for giving a type a useful default value](https://doc.rust-lang.org/std/default/trait.Default.html)
  * [`std::env` - inspection and manipulation of the processâ€™ environment](https://doc.rust-lang.org/std/env/index.html)
    * [`std::env::join_paths` - joins a collection of `Path`s appropriately for the `PATH` environment variable](https://doc.rust-lang.org/std/env/fn.join_paths.html)
  * [`std::error` - interfaces for working with errors](https://doc.rust-lang.org/std/error/index.html)
    * [`std::error::Error` - a trait representing the basic expectations for error values](https://doc.rust-lang.org/std/error/trait.Error.html)
  * [`std::ffi` - utilities related to FFI bindings](https://doc.rust-lang.org/std/ffi/index.html)
    * [`std::ffi::OsStr` - borrowed reference to an OS string](https://doc.rust-lang.org/std/ffi/struct.OsStr.html)
    * [`std::ffi::OsString` - owned mutable platform-native string](https://doc.rust-lang.org/std/ffi/struct.OsString.html)
  * [`std::fmt` - utilities for formatting and printing `String`s](https://doc.rust-lang.org/std/fmt/)
  * [`std::fs` - file system manipulation operations](https://doc.rust-lang.org/std/fs/index.html)
    * [`std::fs::FileType` - a type of file with accessors for each file type](https://doc.rust-lang.org/nightly/std/fs/struct.FileType.html)
  * [`std::hash` - generic hashing support](https://doc.rust-lang.org/std/hash/index.html)
    * [`std::hash::BuildHasher` - a trait for creating instances of `Hasher`](https://doc.rust-lang.org/std/hash/trait.BuildHasher.html)
    * [`std::hash::Hasher` - a trait for hashing an arbitrary stream of bytes](https://doc.rust-lang.org/std/hash/trait.Hasher.html)
  * [`std::io` - the I/O module](https://doc.rust-lang.org/std/io/index.html)
    * [`std::io::Result` - a specialized `Result` type for I/O operations](https://doc.rust-lang.org/std/io/type.Result.html)
    * [`std::io::Stdin` - a handle to the standard input stream of a process](https://doc.rust-lang.org/std/io/struct.Stdin.html)
  * [`std::iter` - composable external iteration](https://doc.rust-lang.org/std/iter/index.html)
    * [`std::iter::Extend` - extend a collection with the contents of an iterator](https://doc.rust-lang.org/std/iter/trait.Extend.html)
    * [`std::iter::IntoIterator` - conversion into an `Iterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html)
    * [`std::iter::Iterator` - a trait for dealing with iterators](https://doc.rust-lang.org/std/iter/trait.Iterator.html)
  * [`std::marker` - primitive traits and types representing basic properties of types](https://doc.rust-lang.org/std/marker/index.html)
    * [`std::marker::Copy` - types whose values can be duplicated simply by copying bits](https://doc.rust-lang.org/std/marker/trait.Copy.html)
    * [`std::marker::PhantomData` - zero-sized type used to mark things that "act like" they own a `T`](https://doc.rust-lang.org/std/marker/struct.PhantomData.html)
    * [`std::marker::Send` - types that can be transferred across thread boundaries](https://doc.rust-lang.org/std/marker/trait.Send.html)
    * [`std::marker::Sized` - types with a constant size known at compile time](https://doc.rust-lang.org/std/marker/trait.Sized.html)
    * [`std::marker::Sync` - types for which it is safe to share references between threads](https://doc.rust-lang.org/std/marker/trait.Sync.html)
    * [`std::marker::Unpin` - types that do not require any pinning guarantees](https://doc.rust-lang.org/std/marker/trait.Unpin.html)
    * [`std::marker::Unsize` - types that can be "unsized" to a dynamically-sized type](https://doc.rust-lang.org/std/marker/trait.Unsize.html)
  * [`std::mem` - basic functions for dealing with memory](https://doc.rust-lang.org/std/mem/index.html)
  * [`std::net` - networking primitives for TCP/UDP communication](https://doc.rust-lang.org/std/net/index.html)
  * [`std::ops` - overloadable operators](https://doc.rust-lang.org/std/ops/index.html)
    * [`std::ops::CoerceUnsized` - trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee](https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html)
    * [`std::ops::Drop` - custom code within a destructor](https://doc.rust-lang.org/std/ops/trait.Drop.html)
  * [`std::option` - optional values](https://doc.rust-lang.org/std/option/index.html)
    * [`std::option::Option` - the `Option` type](https://doc.rust-lang.org/std/option/enum.Option.html)
  * [`std::path` - cross-platform path manipulation](https://doc.rust-lang.org/std/path/index.html)
    * [`std::path::Path` - a slice of a path](https://doc.rust-lang.org/std/path/struct.Path.html)
    * [`std::path::PathBuf` - an owned, mutable path](https://doc.rust-lang.org/std/path/struct.PathBuf.html)
  * [`std::prelude` - the list of symbols which is preloaded](https://doc.rust-lang.org/std/prelude/index.html)
  * [`std::process` - a module for working with processes](https://doc.rust-lang.org/std/process/index.html)
    * [`std::process::Command` - a process builder](https://doc.rust-lang.org/std/process/struct.Command.html)
    * [`std::process::Output` - the output of a finished process](https://doc.rust-lang.org/std/process/struct.Output.html)
  * [`std::result` - error handling with the `Result` type](https://doc.rust-lang.org/std/result/index.html)
    * [`std::result::Result` - a type that represents either success (`Ok`) or failure (`Err`)](https://doc.rust-lang.org/std/result/enum.Result.html)
  * [`std::str` - utilities for the `str` primitive type](https://doc.rust-lang.org/std/str/index.html) [[`str` primitive type](https://doc.rust-lang.org/std/primitive.str.html)]
  * [`std::string` - a growable UTF-8 string module](https://doc.rust-lang.org/std/string/index.html)
    * [`std::string::String` - a growable UTF-8 string](https://doc.rust-lang.org/std/string/struct.String.html)
  * [`std::vec` - a contiguous growable array type with heap-allocated contents](https://doc.rust-lang.org/std/vec/index.html)
    * [`std::vec::Vec` - a contiguous growable array type](https://doc.rust-lang.org/std/vec/struct.Vec.html)
* [`strsim` - string similarity metrics](https://crates.io/crates/strsim) [[doc](https://docs.rs/strsim/latest/strsim)] [[repo](https://github.com/rapidfuzz/strsim-rs)]
* [`syn` - parser for Rust source code](https://crates.io/crates/syn) [[doc](https://docs.rs/syn/latest/syn)] [[repo](https://github.com/dtolnay/syn)]
* [`tao` - cross-platform window manager library](https://crates.io/crates/tao) [[doc](https://docs.rs/tao/latest/tao)] [[repo](https://github.com/tauri-apps/tao)]
* [`tauri` - a framework for building tiny, blazing fast binaries for all major desktop platforms](https://crates.io/crates/tauri) [[home](https://tauri.app/)] [[doc](https://docs.rs/tauri/latest/tauri)] [[repo](https://github.com/tauri-apps/tauri)]
* [`test-context` - custom setup/teardown without test harness](https://crates.io/crates/test-context) [[doc](https://docs.rs/test-context/latest/test_context)] [[repo](https://github.com/JasterV/test-context)]
* [`thiserror` - `derive(Error)`](https://crates.io/crates/thiserror) [[doc](https://docs.rs/thiserror/latest/thiserror)] [[repo](https://github.com/dtolnay/thiserror)]
* [`thread_local` - per-object thread-local storage](https://crates.io/crates/thread_local) [[doc](https://docs.rs/thread_local/latest/thread_local)] [[repo](https://github.com/Amanieu/thread_local-rs)]
* [`time` - date and time library](https://crates.io/crates/time) [[home](https://time-rs.github.io/)] [[doc](https://docs.rs/time/latest/time)] [[api](https://time-rs.github.io/api/time/)] [[repo](https://github.com/time-rs/time)]
* [`ungrammar` - a DSL for specifying concrete syntax trees](https://crates.io/crates/ungrammar) [[doc](https://docs.rs/ungrammar/latest/ungrammar)] [[repo](https://github.com/rust-analyzer/ungrammar)]
  * [Introducing Ungrammar](https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html)
* [`url` - URL library for Rust](https://crates.io/crates/url) [[doc](https://docs.rs/url/latest/url)] [[repo](https://github.com/servo/rust-url)]
* [`urlencoding` - URL percentage encoding and decoding library](https://crates.io/crates/urlencoding) [[doc](https://docs.rs/urlencoding/latest/urlencoding)] [[repo](https://github.com/kornelski/rust_urlencoding)]
* [`walkdir` - recursively walk a directory](https://crates.io/crates/walkdir) [[doc](https://docs.rs/walkdir/latest/walkdir)] [[repo](https://github.com/BurntSushi/walkdir)]
* [`which` - a Rust equivalent of Unix command `which`](https://crates.io/crates/which) [[doc](https://docs.rs/which/latest/which)] [[repo](https://github.com/harryfei/which-rs)]
* [`xshell` - quick shell scripting in Rust](https://crates.io/crates/xshell) [[doc](https://docs.rs/xshell/latest/xshell)] [[repo](https://github.com/matklad/xshell)]
* [`xz2` - binding to `liblzma` providing read/write access to `xz` streams](https://crates.io/crates/xz2) [[doc](https://docs.rs/xz2/latest/xz2)] [[repo](https://github.com/alexcrichton/xz2-rs)]
